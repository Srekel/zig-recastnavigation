// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

pub const dtNodeFlags = extern struct {
    bits: c_int = 0,

    pub const DT_NODE_OPEN: dtNodeFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    pub const DT_NODE_CLOSED: dtNodeFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// parent of the node is not adjacent. Found using raycast.
    pub const DT_NODE_PARENT_DETACHED: dtNodeFlags = .{ .bits = @as(c_uint, @intCast(4)) };

    // pub usingnamespace cpp.FlagsMixin(dtNodeFlags);
};

pub const dtNodeIndex = c_ushort;

extern const _1_DT_NULL_IDX_: *const dtNodeIndex;
pub const DT_NULL_IDX = _1_DT_NULL_IDX_;

extern const _1_DT_NODE_PARENT_BITS_: *const c_int;
pub const DT_NODE_PARENT_BITS = _1_DT_NODE_PARENT_BITS_;

extern const _1_DT_NODE_STATE_BITS_: *const c_int;
pub const DT_NODE_STATE_BITS = _1_DT_NODE_STATE_BITS_;

pub const dtNode = extern struct {
    /// Position of the node.
    pos: [3]f32,
    /// Cost from previous node to current node.
    cost: f32,
    /// Cost up to the node.
    total: f32,
    field_1: packed struct(u32) {
        /// Index to parent node.
        pidx: u24,
        /// extra state information. A polyRef can have multiple nodes with different extra info. see DT_MAX_STATES_PER_NODE
        state: u2,
        /// Node flags. A combination of dtNodeFlags.
        flags: u3,
        /// Padding added by c2z
        _dummy_padding: u3,
    },
    /// Polygon ref the node corresponds to.
    id: dtPolyRef,
};

extern const _1_DT_MAX_STATES_PER_NODE_: *const c_int;
pub const DT_MAX_STATES_PER_NODE = _1_DT_MAX_STATES_PER_NODE_;

pub const dtNodePool = extern struct {
    m_nodes: [*c]dtNode,
    m_first: [*c]dtNodeIndex,
    m_next: [*c]dtNodeIndex,
    m_maxNodes: c_int,
    m_hashSize: c_int,
    m_nodeCount: c_int,

    extern fn _1_dtNodePool_init_(self: *dtNodePool, maxNodes: c_int, hashSize: c_int) void;
    pub const init = _1_dtNodePool_init_;

    extern fn _1_dtNodePool_deinit_(self: *dtNodePool) void;
    pub const deinit = _1_dtNodePool_deinit_;

    extern fn _1_dtNodePool_clear_(self: *dtNodePool) void;
    pub const clear = _1_dtNodePool_clear_;

    extern fn _1_dtNodePool_getNode_(self: *dtNodePool, id: dtPolyRef, state: u8) [*c]dtNode;
    /// Get a dtNode by ref and extra state information. If there is none then - allocate
    /// There can be more than one node for the same polyRef but with different extra state information
    pub fn getNode(
        self: *dtNodePool,
        id: dtPolyRef,
        __opt: struct {
            state: u8 = @as(u8, @intCast(0)),
        },
    ) [*c]dtNode {
        return _1_dtNodePool_getNode_(self, id, __opt.state);
    }

    extern fn _1_dtNodePool_findNode_(self: *dtNodePool, id: dtPolyRef, state: u8) [*c]dtNode;
    pub const findNode = _1_dtNodePool_findNode_;

    extern fn _1_dtNodePool_findNodes_(self: *dtNodePool, id: dtPolyRef, nodes: [*c][*c]dtNode, maxNodes: c_int) c_uint;
    pub const findNodes = _1_dtNodePool_findNodes_;

    pub inline fn getNodeIdx(self: *const dtNodePool, node: [*c]const dtNode) c_uint {
        if (!node != null) return @as(c_uint, @intCast(0));
        return @as(c_uint, @intCast((node - self.m_nodes))) + @as(c_uint, @intCast(1));
    }
    pub inline fn getNodeAtIdx(self: *dtNodePool, idx: c_uint) [*c]dtNode {
        if (!((idx) != 0)) return null;
        return &self.m_nodes[idx - @as(c_uint, @intCast(1))];
    }
    pub inline fn getNodeAtIdx__Overload2(self: *const dtNodePool, idx: c_uint) [*c]const dtNode {
        if (!((idx) != 0)) return null;
        return &self.m_nodes[idx - @as(c_uint, @intCast(1))];
    }
    pub inline fn getMemUsed(self: *const dtNodePool) c_int {
        return @as(c_int, @intCast(@sizeOf(self.*) + @sizeOf(dtNode) * @as(c_ulonglong, @intCast(self.m_maxNodes)) + @sizeOf(dtNodeIndex) * @as(c_ulonglong, @intCast(self.m_maxNodes)) + @sizeOf(dtNodeIndex) * @as(c_ulonglong, @intCast(self.m_hashSize))));
    }
    pub inline fn getMaxNodes(self: *const dtNodePool) c_int {
        return self.m_maxNodes;
    }
    pub inline fn getHashSize(self: *const dtNodePool) c_int {
        return self.m_hashSize;
    }
    pub inline fn getFirst(self: *const dtNodePool, bucket: c_int) dtNodeIndex {
        return self.m_first[bucket];
    }
    pub inline fn getNext(self: *const dtNodePool, i: c_int) dtNodeIndex {
        return self.m_next[i];
    }
    pub inline fn getNodeCount(self: *const dtNodePool) c_int {
        return self.m_nodeCount;
    }
};

pub const dtNodeQueue = extern struct {
    m_heap: [*c][*c]dtNode,
    m_capacity: c_int,
    m_size: c_int,

    extern fn _1_dtNodeQueue_init_(self: *dtNodeQueue, n: c_int) void;
    pub const init = _1_dtNodeQueue_init_;

    extern fn _1_dtNodeQueue_deinit_(self: *dtNodeQueue) void;
    pub const deinit = _1_dtNodeQueue_deinit_;

    pub inline fn clear(self: *dtNodeQueue) void {
        self.m_size = 0;
    }
    pub inline fn top(self: *dtNodeQueue) [*c]dtNode {
        return self.m_heap[0];
    }
    pub inline fn pop(self: *dtNodeQueue) [*c]dtNode {
        var result: [*c]dtNode = self.m_heap[0];
        self.m_size -= 1;
        self.trickleDown(0, self.m_heap[self.m_size]);
        return result;
    }
    pub inline fn push(self: *dtNodeQueue, node: [*c]dtNode) void {
        self.m_size += 1;
        self.bubbleUp(self.m_size - 1, node);
    }
    pub inline fn modify(self: *dtNodeQueue, node: [*c]dtNode) void {
        {
            var i: c_int = 0;
            while (i < self.m_size) : (i += 1) {
                if (self.m_heap[i] == node) {
                    self.bubbleUp(i, node);
                    return;
                }
            }
        }
    }
    pub inline fn empty(self: *const dtNodeQueue) bool {
        return self.m_size == 0;
    }
    pub inline fn getMemUsed(self: *const dtNodeQueue) c_int {
        return @as(c_int, @intCast(@sizeOf(self.*) + @sizeOf([*c]dtNode) * @as(c_ulonglong, @intCast((self.m_capacity + 1)))));
    }
    pub inline fn getCapacity(self: *const dtNodeQueue) c_int {
        return self.m_capacity;
    }
};
