// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

pub const dtPolyRef = c_uint;

pub const dtTileRef = c_uint;

extern const _1_DT_VERTS_PER_POLYGON_: *const c_int;
pub const DT_VERTS_PER_POLYGON = _1_DT_VERTS_PER_POLYGON_;

extern const _1_DT_NAVMESH_MAGIC_: *const c_int;
pub const DT_NAVMESH_MAGIC = _1_DT_NAVMESH_MAGIC_;

extern const _1_DT_NAVMESH_VERSION_: *const c_int;
pub const DT_NAVMESH_VERSION = _1_DT_NAVMESH_VERSION_;

extern const _1_DT_NAVMESH_STATE_MAGIC_: *const c_int;
pub const DT_NAVMESH_STATE_MAGIC = _1_DT_NAVMESH_STATE_MAGIC_;

extern const _1_DT_NAVMESH_STATE_VERSION_: *const c_int;
pub const DT_NAVMESH_STATE_VERSION = _1_DT_NAVMESH_STATE_VERSION_;

extern const _1_DT_EXT_LINK_: *const c_ushort;
pub const DT_EXT_LINK = _1_DT_EXT_LINK_;

extern const _1_DT_NULL_LINK_: *const c_uint;
pub const DT_NULL_LINK = _1_DT_NULL_LINK_;

extern const _1_DT_OFFMESH_CON_BIDIR_: *const c_uint;
pub const DT_OFFMESH_CON_BIDIR = _1_DT_OFFMESH_CON_BIDIR_;

extern const _1_DT_MAX_AREAS_: *const c_int;
pub const DT_MAX_AREAS = _1_DT_MAX_AREAS_;

/// Tile flags used for various functions and fields.
/// For an example, see dtNavMesh::addTile().
pub const dtTileFlags = extern struct {
    bits: c_int = 0,

    /// The navigation mesh owns the tile memory and is responsible for freeing it.
    pub const DT_TILE_FREE_DATA: dtTileFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(dtTileFlags);
};

/// Vertex flags returned by dtNavMeshQuery::findStraightPath.
pub const dtStraightPathFlags = extern struct {
    bits: c_int = 0,

    /// The vertex is the start position in the path.
    pub const DT_STRAIGHTPATH_START: dtStraightPathFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// The vertex is the end position in the path.
    pub const DT_STRAIGHTPATH_END: dtStraightPathFlags = .{ .bits = @as(c_uint, @intCast(2)) };
    /// The vertex is the start of an off-mesh connection.
    pub const DT_STRAIGHTPATH_OFFMESH_CONNECTION: dtStraightPathFlags = .{ .bits = @as(c_uint, @intCast(4)) };

    // pub usingnamespace cpp.FlagsMixin(dtStraightPathFlags);
};

/// Options for dtNavMeshQuery::findStraightPath.
pub const dtStraightPathOptions = extern struct {
    bits: c_int = 0,

    /// Add a vertex at every polygon edge crossing where area changes.
    pub const DT_STRAIGHTPATH_AREA_CROSSINGS: dtStraightPathOptions = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Add a vertex at every polygon edge crossing.
    pub const DT_STRAIGHTPATH_ALL_CROSSINGS: dtStraightPathOptions = .{ .bits = @as(c_uint, @intCast(2)) };

    // pub usingnamespace cpp.FlagsMixin(dtStraightPathOptions);
};

/// Options for dtNavMeshQuery::initSlicedFindPath and updateSlicedFindPath
pub const dtFindPathOptions = extern struct {
    bits: c_int = 0,

    /// use raycasts during pathfind to "shortcut" (raycast still consider costs)
    pub const DT_FINDPATH_ANY_ANGLE: dtFindPathOptions = .{ .bits = @as(c_uint, @intCast(2)) };

    // pub usingnamespace cpp.FlagsMixin(dtFindPathOptions);
};

/// Options for dtNavMeshQuery::raycast
pub const dtRaycastOptions = extern struct {
    bits: c_int = 0,

    /// Raycast should calculate movement cost along the ray and fill RaycastHit::cost
    pub const DT_RAYCAST_USE_COSTS: dtRaycastOptions = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(dtRaycastOptions);
};

pub const dtDetailTriEdgeFlags = extern struct {
    bits: c_int = 0,

    /// Detail triangle edge is part of the poly boundary
    pub const DT_DETAIL_EDGE_BOUNDARY: dtDetailTriEdgeFlags = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(dtDetailTriEdgeFlags);
};

extern const _1_DT_RAY_CAST_LIMIT_PROPORTIONS_: *const f32;
pub const DT_RAY_CAST_LIMIT_PROPORTIONS = _1_DT_RAY_CAST_LIMIT_PROPORTIONS_;

/// Flags representing the type of a navigation mesh polygon.
pub const dtPolyTypes = extern struct {
    bits: c_int = 0,

    /// The polygon is a standard convex polygon that is part of the surface of the mesh.
    pub const DT_POLYTYPE_GROUND: dtPolyTypes = .{ .bits = @as(c_uint, @intCast(0)) };
    /// The polygon is an off-mesh connection consisting of two vertices.
    pub const DT_POLYTYPE_OFFMESH_CONNECTION: dtPolyTypes = .{ .bits = @as(c_uint, @intCast(1)) };

    // pub usingnamespace cpp.FlagsMixin(dtPolyTypes);
};

/// Defines a polygon within a dtMeshTile object.
/// @UntranspiledVerbatimLineCommentCommand detour
pub const dtPoly = extern struct {
    /// Index to first link in linked list. (Or #DT_NULL_LINK if there is no link.)
    firstLink: c_uint,
    /// The indices of the polygon's vertices.
    /// The actual vertices are located in dtMeshTile::verts.
    verts: [6]c_ushort,
    /// Packed data representing neighbor polygons references and flags for each edge.
    neis: [6]c_ushort,
    /// The user defined polygon flags.
    flags: c_ushort,
    /// The number of vertices in the polygon.
    vertCount: u8,
    /// The bit packed area id and polygon type.
    /// @see Use the structure's set and get methods to access this value.
    areaAndtype: u8,

    extern fn _1_dtPoly_setArea_(self: *dtPoly, a: u8) void;
    /// Sets the user defined area id. [Limit:
    ///<
    /// #DT_MAX_AREAS]
    pub const setArea = _1_dtPoly_setArea_;

    extern fn _1_dtPoly_setType_(self: *dtPoly, t: u8) void;
    /// Sets the polygon type. (See: #dtPolyTypes.)
    pub const setType = _1_dtPoly_setType_;

    extern fn _1_dtPoly_getArea_(self: *const dtPoly) u8;
    /// Gets the user defined area id.
    pub const getArea = _1_dtPoly_getArea_;

    extern fn _1_dtPoly_getType_(self: *const dtPoly) u8;
    /// Gets the polygon type. (See: #dtPolyTypes)
    pub const getType = _1_dtPoly_getType_;
};

/// Defines the location of detail sub-mesh data within a dtMeshTile.
pub const dtPolyDetail = extern struct {
    /// The offset of the vertices in the dtMeshTile::detailVerts array.
    vertBase: c_uint,
    /// The offset of the triangles in the dtMeshTile::detailTris array.
    triBase: c_uint,
    /// The number of vertices in the sub-mesh.
    vertCount: u8,
    /// The number of triangles in the sub-mesh.
    triCount: u8,
};

/// Defines a link between polygons.
/// @see This structure is rarely if ever used by the end user.
/// @see dtMeshTile
pub const dtLink = extern struct {
    /// Neighbour reference. (The neighbor that is linked to.)
    ref: dtPolyRef,
    /// Index of the next link.
    next: c_uint,
    /// Index of the polygon edge that owns this link.
    edge: u8,
    /// If a boundary link, defines on which side the link is.
    side: u8,
    /// If a boundary link, defines the minimum sub-edge area.
    bmin: u8,
    /// If a boundary link, defines the maximum sub-edge area.
    bmax: u8,
};

/// Bounding volume node.
/// @see This structure is rarely if ever used by the end user.
/// @see dtMeshTile
pub const dtBVNode = extern struct {
    /// Minimum bounds of the node's AABB. [(x, y, z)]
    bmin: [3]c_ushort,
    /// Maximum bounds of the node's AABB. [(x, y, z)]
    bmax: [3]c_ushort,
    /// The node's index. (Negative for escape sequence.)
    i: c_int,
};

/// Defines an navigation mesh off-mesh connection within a dtMeshTile object.
/// An off-mesh connection is a user defined traversable connection made up to two vertices.
pub const dtOffMeshConnection = extern struct {
    /// The endpoints of the connection. [(ax, ay, az, bx, by, bz)]
    pos: [6]f32,
    /// The radius of the endpoints. [Limit: >= 0]
    rad: f32,
    /// The polygon reference of the connection within the tile.
    poly: c_ushort,
    /// Link flags.
    /// @see These are not the connection's user defined flags. Those are assigned via the
    /// connection's dtPoly definition. These are link flags used for internal purposes.
    flags: u8,
    /// End point side.
    side: u8,
    /// The id of the offmesh connection. (User assigned when the navigation mesh is built.)
    userId: c_uint,
};

/// Provides high level information related to a dtMeshTile object.
/// @UntranspiledVerbatimLineCommentCommand detour
pub const dtMeshHeader = extern struct {
    /// Tile magic number. (Used to identify the data format.)
    magic: c_int,
    /// Tile data format version number.
    version: c_int,
    /// The x-position of the tile within the dtNavMesh tile grid. (x, y, layer)
    x: c_int,
    /// The y-position of the tile within the dtNavMesh tile grid. (x, y, layer)
    y: c_int,
    /// The layer of the tile within the dtNavMesh tile grid. (x, y, layer)
    layer: c_int,
    /// The user defined id of the tile.
    userId: c_uint,
    /// The number of polygons in the tile.
    polyCount: c_int,
    /// The number of vertices in the tile.
    vertCount: c_int,
    /// The number of allocated links.
    maxLinkCount: c_int,
    /// The number of sub-meshes in the detail mesh.
    detailMeshCount: c_int,
    /// The number of unique vertices in the detail mesh. (In addition to the polygon vertices.)
    detailVertCount: c_int,
    /// The number of triangles in the detail mesh.
    detailTriCount: c_int,
    /// The number of bounding volume nodes. (Zero if bounding volumes are disabled.)
    bvNodeCount: c_int,
    /// The number of off-mesh connections.
    offMeshConCount: c_int,
    /// The index of the first polygon which is an off-mesh connection.
    offMeshBase: c_int,
    /// The height of the agents using the tile.
    walkableHeight: f32,
    /// The radius of the agents using the tile.
    walkableRadius: f32,
    /// The maximum climb height of the agents using the tile.
    walkableClimb: f32,
    /// The minimum bounds of the tile's AABB. [(x, y, z)]
    bmin: [3]f32,
    /// The maximum bounds of the tile's AABB. [(x, y, z)]
    bmax: [3]f32,
    /// The bounding volume quantization factor.
    bvQuantFactor: f32,
};

/// Defines a navigation mesh tile.
/// @UntranspiledVerbatimLineCommentCommand detour
pub const dtMeshTile = extern struct {
    /// Counter describing modifications to the tile.
    salt: c_uint,
    /// Index to the next free link.
    linksFreeList: c_uint,
    /// The tile header.
    header: [*c]dtMeshHeader,
    /// The tile polygons. [Size: dtMeshHeader::polyCount]
    polys: [*c]dtPoly,
    /// The tile vertices. [(x, y, z) * dtMeshHeader::vertCount]
    verts: [*c]f32,
    /// The tile links. [Size: dtMeshHeader::maxLinkCount]
    links: [*c]dtLink,
    /// The tile's detail sub-meshes. [Size: dtMeshHeader::detailMeshCount]
    detailMeshes: [*c]dtPolyDetail,
    /// The detail mesh's unique vertices. [(x, y, z) * dtMeshHeader::detailVertCount]
    detailVerts: [*c]f32,
    /// The detail mesh's triangles. [(vertA, vertB, vertC, triFlags) * dtMeshHeader::detailTriCount].
    /// See dtDetailTriEdgeFlags and dtGetDetailTriEdgeFlags.
    detailTris: [*c]u8,
    /// The tile bounding volume nodes. [Size: dtMeshHeader::bvNodeCount]
    /// (Will be null if bounding volumes are disabled.)
    bvTree: [*c]dtBVNode,
    /// The tile off-mesh connections. [Size: dtMeshHeader::offMeshConCount]
    offMeshCons: [*c]dtOffMeshConnection,
    /// The tile data. (Not directly accessed under normal situations.)
    data: [*c]u8,
    /// Size of the tile data.
    dataSize: c_int,
    /// Tile flags. (See: #dtTileFlags)
    flags: c_int,
    /// The next free tile, or the next tile in the spatial grid.
    next: [*c]dtMeshTile,
};

extern fn _1_dtGetDetailTriEdgeFlags_(triFlags: u8, edgeIndex: c_int) c_int;
/// Get flags for edge in detail triangle.
/// @param[in] triFlags 		The flags for the triangle (last component of detail vertices above).
/// @param[in] edgeIndex 		The index of the first vertex of the edge. For instance, if 0,
///								returns flags for edge AB.
pub const dtGetDetailTriEdgeFlags = _1_dtGetDetailTriEdgeFlags_;

/// Configuration parameters used to define multi-tile navigation meshes.
/// The values are used to allocate space during the initialization of a navigation mesh.
/// @see dtNavMesh::init()
/// @UntranspiledVerbatimLineCommentCommand detour
pub const dtNavMeshParams = extern struct {
    /// The world space origin of the navigation mesh's tile space. [(x, y, z)]
    orig: [3]f32,
    /// The width of each tile. (Along the x-axis.)
    tileWidth: f32,
    /// The height of each tile. (Along the z-axis.)
    tileHeight: f32,
    /// The maximum number of tiles the navigation mesh can contain. This and maxPolys are used to calculate how many bits are needed to identify tiles and polygons uniquely.
    maxTiles: c_int,
    /// The maximum number of polygons each tile can contain. This and maxTiles are used to calculate how many bits are needed to identify tiles and polygons uniquely.
    maxPolys: c_int,
};

/// A navigation mesh based on tiles of convex polygons.
/// @UntranspiledVerbatimLineCommentCommand detour
pub const dtNavMesh = extern struct {
    /// Current initialization params. TODO: do not store this info twice.
    m_params: dtNavMeshParams,
    /// Origin of the tile (0,0)
    m_orig: [3]f32,
    /// Dimensions of each tile.
    m_tileWidth: f32,
    /// Dimensions of each tile.
    m_tileHeight: f32,
    /// Max number of tiles.
    m_maxTiles: c_int,
    /// Tile hash lookup size (must be pot).
    m_tileLutSize: c_int,
    /// Tile hash lookup mask.
    m_tileLutMask: c_int,
    /// Tile hash lookup.
    m_posLookup: [*c][*c]dtMeshTile,
    /// Freelist of tiles.
    m_nextFree: [*c]dtMeshTile,
    /// List of tiles.
    m_tiles: [*c]dtMeshTile,
    /// Number of salt bits in the tile ID.
    m_saltBits: c_uint,
    /// Number of tile bits in the tile ID.
    m_tileBits: c_uint,
    /// Number of poly bits in the tile ID.
    m_polyBits: c_uint,

    extern fn _1_dtNavMesh_init_(self: *dtNavMesh) void;
    pub const init = _1_dtNavMesh_init_;

    extern fn _1_dtNavMesh_deinit_(self: *dtNavMesh) void;
    pub const deinit = _1_dtNavMesh_deinit_;

    extern fn _1_dtNavMesh_init_(self: *dtNavMesh, params: [*c]const dtNavMeshParams) dtStatus;
    /// Initializes the navigation mesh for tiled use.
    ///  @param[in] params 		Initialization parameters.
    /// @see The status flags for the operation.
    pub const init = _1_dtNavMesh_init_;

    extern fn _2_dtNavMesh_init_(self: *dtNavMesh, data: [*c]u8, dataSize: c_int, flags: c_int) dtStatus;
    /// Initializes the navigation mesh for single tile use.
    ///  @param[in] data 		Data of the new tile. (See: #dtCreateNavMeshData)
    ///  @param[in] dataSize 	The data size of the new tile.
    ///  @param[in] flags 		The tile flags. (See: #dtTileFlags)
    /// @see The status flags for the operation.
    ///  @see dtCreateNavMeshData
    pub const init__Overload2 = _2_dtNavMesh_init_;

    extern fn _1_dtNavMesh_getParams_(self: *const dtNavMesh) [*c]const dtNavMeshParams;
    /// The navigation mesh initialization params.
    pub const getParams = _1_dtNavMesh_getParams_;

    extern fn _1_dtNavMesh_addTile_(self: *dtNavMesh, data: [*c]u8, dataSize: c_int, flags: c_int, lastRef: dtTileRef, result: [*c]dtTileRef) dtStatus;
    /// Adds a tile to the navigation mesh.
    ///  @param[in] data 		Data for the new tile mesh. (See: #dtCreateNavMeshData)
    ///  @param[in] dataSize 	Data size of the new tile mesh.
    ///  @param[in] flags 		Tile flags. (See: #dtTileFlags)
    ///  @param[in] lastRef 		The desired reference for the tile. (When reloading a tile.) [opt] [Default: 0]
    ///  @param[out] result 		The tile reference. (If the tile was succesfully added.) [opt]
    /// @see The status flags for the operation.
    pub const addTile = _1_dtNavMesh_addTile_;

    extern fn _1_dtNavMesh_removeTile_(self: *dtNavMesh, ref: dtTileRef, data: [*c][*c]u8, dataSize: [*c]c_int) dtStatus;
    /// Removes the specified tile from the navigation mesh.
    ///  @param[in] ref 			The reference of the tile to remove.
    ///  @param[out] data 		Data associated with deleted tile.
    ///  @param[out] dataSize 	Size of the data associated with deleted tile.
    /// @see The status flags for the operation.
    pub const removeTile = _1_dtNavMesh_removeTile_;

    extern fn _1_dtNavMesh_calcTileLoc_(self: *const dtNavMesh, pos: [*c]const f32, tx: [*c]c_int, ty: [*c]c_int) void;
    /// Calculates the tile grid location for the specified world position.
    ///  @param[in] pos   The world position for the query. [(x, y, z)]
    ///  @param[out] tx 		The tile's x-location. (x, y)
    ///  @param[out] ty 		The tile's y-location. (x, y)
    pub const calcTileLoc = _1_dtNavMesh_calcTileLoc_;

    extern fn _1_dtNavMesh_getTileAt_(self: *const dtNavMesh, x: c_int, y: c_int, layer: c_int) [*c]const dtMeshTile;
    /// Gets the tile at the specified grid location.
    ///  @param[in] x 		The tile's x-location. (x, y, layer)
    ///  @param[in] y 		The tile's y-location. (x, y, layer)
    ///  @param[in] layer 	The tile's layer. (x, y, layer)
    /// @see The tile, or null if the tile does not exist.
    pub const getTileAt = _1_dtNavMesh_getTileAt_;

    extern fn _1_dtNavMesh_getTilesAt_(self: *const dtNavMesh, x: c_int, y: c_int, tiles: [*c]const [*c]dtMeshTile, maxTiles: c_int) c_int;
    /// Gets all tiles at the specified grid location. (All layers.)
    ///  @param[in] x 			The tile's x-location. (x, y)
    ///  @param[in] y 			The tile's y-location. (x, y)
    ///  @param[out] tiles 		A pointer to an array of tiles that will hold the result.
    ///  @param[in] maxTiles 	The maximum tiles the tiles parameter can hold.
    /// @see The number of tiles returned in the tiles array.
    pub const getTilesAt = _1_dtNavMesh_getTilesAt_;

    extern fn _1_dtNavMesh_getTileRefAt_(self: *const dtNavMesh, x: c_int, y: c_int, layer: c_int) dtTileRef;
    /// Gets the tile reference for the tile at specified grid location.
    ///  @param[in] x 		The tile's x-location. (x, y, layer)
    ///  @param[in] y 		The tile's y-location. (x, y, layer)
    ///  @param[in] layer 	The tile's layer. (x, y, layer)
    /// @see The tile reference of the tile, or 0 if there is none.
    pub const getTileRefAt = _1_dtNavMesh_getTileRefAt_;

    extern fn _1_dtNavMesh_getTileRef_(self: *const dtNavMesh, tile: [*c]const dtMeshTile) dtTileRef;
    /// Gets the tile reference for the specified tile.
    ///  @param[in] tile 	The tile.
    /// @see The tile reference of the tile.
    pub const getTileRef = _1_dtNavMesh_getTileRef_;

    extern fn _1_dtNavMesh_getTileByRef_(self: *const dtNavMesh, ref: dtTileRef) [*c]const dtMeshTile;
    /// Gets the tile for the specified tile reference.
    ///  @param[in] ref 		The tile reference of the tile to retrieve.
    /// @see The tile for the specified reference, or null if the
    ///		reference is invalid.
    pub const getTileByRef = _1_dtNavMesh_getTileByRef_;

    extern fn _1_dtNavMesh_getMaxTiles_(self: *const dtNavMesh) c_int;
    /// The maximum number of tiles supported by the navigation mesh.
    /// @see The maximum number of tiles supported by the navigation mesh.
    pub const getMaxTiles = _1_dtNavMesh_getMaxTiles_;

    extern fn _1_dtNavMesh_getTile_(self: *const dtNavMesh, i: c_int) [*c]const dtMeshTile;
    /// Gets the tile at the specified index.
    ///  @param[in] i 		The tile index. [Limit: 0 >= index
    ///<
    /// #getMaxTiles()]
    /// @see The tile at the specified index.
    pub const getTile = _1_dtNavMesh_getTile_;

    extern fn _1_dtNavMesh_getTileAndPolyByRef_(self: *const dtNavMesh, ref: dtPolyRef, tile: [*c]const [*c]dtMeshTile, poly: [*c]const [*c]dtPoly) dtStatus;
    /// Gets the tile and polygon for the specified polygon reference.
    ///  @param[in] ref 		The reference for the a polygon.
    ///  @param[out] tile 	The tile containing the polygon.
    ///  @param[out] poly 	The polygon.
    /// @see The status flags for the operation.
    pub const getTileAndPolyByRef = _1_dtNavMesh_getTileAndPolyByRef_;

    extern fn _1_dtNavMesh_getTileAndPolyByRefUnsafe_(self: *const dtNavMesh, ref: dtPolyRef, tile: [*c]const [*c]dtMeshTile, poly: [*c]const [*c]dtPoly) void;
    /// Returns the tile and polygon for the specified polygon reference.
    ///  @param[in] ref 		A known valid reference for a polygon.
    ///  @param[out] tile 	The tile containing the polygon.
    ///  @param[out] poly 	The polygon.
    pub const getTileAndPolyByRefUnsafe = _1_dtNavMesh_getTileAndPolyByRefUnsafe_;

    extern fn _1_dtNavMesh_isValidPolyRef_(self: *const dtNavMesh, ref: dtPolyRef) bool;
    /// Checks the validity of a polygon reference.
    ///  @param[in] ref 		The polygon reference to check.
    /// @see True if polygon reference is valid for the navigation mesh.
    pub const isValidPolyRef = _1_dtNavMesh_isValidPolyRef_;

    extern fn _1_dtNavMesh_getPolyRefBase_(self: *const dtNavMesh, tile: [*c]const dtMeshTile) dtPolyRef;
    /// Gets the polygon reference for the tile's base polygon.
    ///  @param[in] tile 		The tile.
    /// @see The polygon reference for the base polygon in the specified tile.
    pub const getPolyRefBase = _1_dtNavMesh_getPolyRefBase_;

    extern fn _1_dtNavMesh_getOffMeshConnectionPolyEndPoints_(self: *const dtNavMesh, prevRef: dtPolyRef, polyRef: dtPolyRef, startPos: [*c]f32, endPos: [*c]f32) dtStatus;
    /// Gets the endpoints for an off-mesh connection, ordered by "direction of travel".
    ///  @param[in] prevRef 		The reference of the polygon before the connection.
    ///  @param[in] polyRef 		The reference of the off-mesh connection polygon.
    ///  @param[out] startPos 	The start position of the off-mesh connection. [(x, y, z)]
    ///  @param[out] endPos 		The end position of the off-mesh connection. [(x, y, z)]
    /// @see The status flags for the operation.
    pub const getOffMeshConnectionPolyEndPoints = _1_dtNavMesh_getOffMeshConnectionPolyEndPoints_;

    extern fn _1_dtNavMesh_getOffMeshConnectionByRef_(self: *const dtNavMesh, ref: dtPolyRef) [*c]const dtOffMeshConnection;
    /// Gets the specified off-mesh connection.
    ///  @param[in] ref 		The polygon reference of the off-mesh connection.
    /// @see The specified off-mesh connection, or null if the polygon reference is not valid.
    pub const getOffMeshConnectionByRef = _1_dtNavMesh_getOffMeshConnectionByRef_;

    extern fn _1_dtNavMesh_setPolyFlags_(self: *dtNavMesh, ref: dtPolyRef, flags: c_ushort) dtStatus;
    /// Sets the user defined flags for the specified polygon.
    ///  @param[in] ref 		The polygon reference.
    ///  @param[in] flags 	The new flags for the polygon.
    /// @see The status flags for the operation.
    pub const setPolyFlags = _1_dtNavMesh_setPolyFlags_;

    extern fn _1_dtNavMesh_getPolyFlags_(self: *const dtNavMesh, ref: dtPolyRef, resultFlags: [*c]c_ushort) dtStatus;
    /// Gets the user defined flags for the specified polygon.
    ///  @param[in] ref 				The polygon reference.
    ///  @param[out] resultFlags 		The polygon flags.
    /// @see The status flags for the operation.
    pub const getPolyFlags = _1_dtNavMesh_getPolyFlags_;

    extern fn _1_dtNavMesh_setPolyArea_(self: *dtNavMesh, ref: dtPolyRef, area: u8) dtStatus;
    /// Sets the user defined area for the specified polygon.
    ///  @param[in] ref 		The polygon reference.
    ///  @param[in] area 	The new area id for the polygon. [Limit:
    ///<
    /// #DT_MAX_AREAS]
    /// @see The status flags for the operation.
    pub const setPolyArea = _1_dtNavMesh_setPolyArea_;

    extern fn _1_dtNavMesh_getPolyArea_(self: *const dtNavMesh, ref: dtPolyRef, resultArea: [*c]u8) dtStatus;
    /// Gets the user defined area for the specified polygon.
    ///  @param[in] ref 			The polygon reference.
    ///  @param[out] resultArea 	The area id for the polygon.
    /// @see The status flags for the operation.
    pub const getPolyArea = _1_dtNavMesh_getPolyArea_;

    extern fn _1_dtNavMesh_getTileStateSize_(self: *const dtNavMesh, tile: [*c]const dtMeshTile) c_int;
    /// Gets the size of the buffer required by #storeTileState to store the specified tile's state.
    ///  @param[in] tile 	The tile.
    /// @see The size of the buffer required to store the state.
    pub const getTileStateSize = _1_dtNavMesh_getTileStateSize_;

    extern fn _1_dtNavMesh_storeTileState_(self: *const dtNavMesh, tile: [*c]const dtMeshTile, data: [*c]u8, maxDataSize: c_int) dtStatus;
    /// Stores the non-structural state of the tile in the specified buffer. (Flags, area ids, etc.)
    ///  @param[in] tile 			The tile.
    ///  @param[out] data 			The buffer to store the tile's state in.
    ///  @param[in] maxDataSize 		The size of the data buffer. [Limit: >= #getTileStateSize]
    /// @see The status flags for the operation.
    pub const storeTileState = _1_dtNavMesh_storeTileState_;

    extern fn _1_dtNavMesh_restoreTileState_(self: *dtNavMesh, tile: [*c]dtMeshTile, data: [*c]const u8, maxDataSize: c_int) dtStatus;
    /// Restores the state of the tile.
    ///  @param[in] tile 			The tile.
    ///  @param[in] data 			The new state. (Obtained from #storeTileState.)
    ///  @param[in] maxDataSize 		The size of the state within the data buffer.
    /// @see The status flags for the operation.
    pub const restoreTileState = _1_dtNavMesh_restoreTileState_;

    extern fn _1_dtNavMesh_encodePolyId_(self: *const dtNavMesh, salt: c_uint, it: c_uint, ip: c_uint) dtPolyRef;
    /// Derives a standard polygon reference.
    ///  @see This function is generally meant for internal use only.
    ///  @param[in] salt 	The tile's salt value.
    ///  @param[in] it 		The index of the tile.
    ///  @param[in] ip 		The index of the polygon within the tile.
    pub const encodePolyId = _1_dtNavMesh_encodePolyId_;

    extern fn _1_dtNavMesh_decodePolyId_(self: *const dtNavMesh, ref: dtPolyRef, salt: *c_uint, it: *c_uint, ip: *c_uint) void;
    /// Decodes a standard polygon reference.
    ///  @see This function is generally meant for internal use only.
    ///  @param[in] ref    The polygon reference to decode.
    ///  @param[out] salt 	The tile's salt value.
    ///  @param[out] it 		The index of the tile.
    ///  @param[out] ip 		The index of the polygon within the tile.
    ///  @see #encodePolyId
    pub const decodePolyId = _1_dtNavMesh_decodePolyId_;

    extern fn _1_dtNavMesh_decodePolyIdSalt_(self: *const dtNavMesh, ref: dtPolyRef) c_uint;
    /// Extracts a tile's salt value from the specified polygon reference.
    ///  @see This function is generally meant for internal use only.
    ///  @param[in] ref 		The polygon reference.
    ///  @see #encodePolyId
    pub const decodePolyIdSalt = _1_dtNavMesh_decodePolyIdSalt_;

    extern fn _1_dtNavMesh_decodePolyIdTile_(self: *const dtNavMesh, ref: dtPolyRef) c_uint;
    /// Extracts the tile's index from the specified polygon reference.
    ///  @see This function is generally meant for internal use only.
    ///  @param[in] ref 		The polygon reference.
    ///  @see #encodePolyId
    pub const decodePolyIdTile = _1_dtNavMesh_decodePolyIdTile_;

    extern fn _1_dtNavMesh_decodePolyIdPoly_(self: *const dtNavMesh, ref: dtPolyRef) c_uint;
    /// Extracts the polygon's index (within its tile) from the specified polygon reference.
    ///  @see This function is generally meant for internal use only.
    ///  @param[in] ref 		The polygon reference.
    ///  @see #encodePolyId
    pub const decodePolyIdPoly = _1_dtNavMesh_decodePolyIdPoly_;
};

extern fn _1_dtAllocNavMesh_() [*c]dtNavMesh;
/// Allocates a navigation mesh object using the Detour allocator.
/// @see A navigation mesh that is ready for initialization, or null on failure.
///  @UntranspiledVerbatimLineCommentCommand detour
pub const dtAllocNavMesh = _1_dtAllocNavMesh_;

extern fn _1_dtFreeNavMesh_(navmesh: [*c]dtNavMesh) void;
/// Frees the specified navigation mesh object using the Detour allocator.
///  @param[in] navmesh 		A navigation mesh allocated using #dtAllocNavMesh
///  @UntranspiledVerbatimLineCommentCommand detour
pub const dtFreeNavMesh = _1_dtFreeNavMesh_;
