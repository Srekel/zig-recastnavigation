// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

/// Provides hint values to the memory allocator on how long the
/// memory is expected to be used.
pub const rcAllocHint = extern struct {
    bits: c_int = 0,

    /// Memory will persist after a function call.
    pub const RC_ALLOC_PERM: rcAllocHint = .{ .bits = 0 };
    /// Memory used temporarily within a function.
    pub const RC_ALLOC_TEMP: rcAllocHint = .{ .bits = 1 };

    // pub usingnamespace cpp.FlagsMixin(rcAllocHint);
};

/// A memory allocation function.
///  @param[in] size 			The size, in bytes of memory, to allocate.
///  @param[in] rcAllocHint 	A hint to the allocator on how long the memory is expected to be in use.
///  @see A pointer to the beginning of the allocated memory block, or null if the allocation failed.
///  @see rcAllocSetCustom
pub const rcAllocFunc = fn (usize, rcAllocHint) callconv(.C) ?*anyopaque;

/// A memory deallocation function.
///  @param[in] ptr 		A pointer to a memory block previously allocated using #rcAllocFunc.
/// @see rcAllocSetCustom
pub const rcFreeFunc = fn (?*anyopaque) callconv(.C) void;

extern fn _1_rcAllocSetCustom_(allocFunc: [*c]rcAllocFunc, freeFunc: [*c]rcFreeFunc) void;
/// Sets the base custom allocation functions to be used by Recast.
///  @param[in] allocFunc 	The memory allocation function to be used by #rcAlloc
///  @param[in] freeFunc 	The memory de-allocation function to be used by #rcFree
///
/// @see rcAlloc, rcFree
pub const rcAllocSetCustom = _1_rcAllocSetCustom_;

extern fn _1_rcAlloc_(size: usize, hint: rcAllocHint) ?*anyopaque;
/// Allocates a memory block.
///
/// @param[in] size 	The size, in bytes of memory, to allocate.
/// @param[in] hint 	A hint to the allocator on how long the memory is expected to be in use.
/// @see A pointer to the beginning of the allocated memory block, or null if the allocation failed.
///
/// @see rcFree, rcAllocSetCustom
pub const rcAlloc = _1_rcAlloc_;

extern fn _1_rcFree_(ptr: ?*anyopaque) void;
/// Deallocates a memory block.  If
///@p
/// is NULL, this does nothing.
///
/// @see This function leaves the value of
///@p
/// unchanged.  So it still
/// points to the same (now invalid) location, and not to null.
///
/// @param[in] ptr 		A pointer to a memory block previously allocated using #rcAlloc.
///
/// @see rcAlloc, rcAllocSetCustom
pub const rcFree = _1_rcFree_;

/// An implementation of operator new usable for placement new. The default one is part of STL (which we don't use).
/// rcNewTag is a dummy type used to differentiate our operator from the STL one, in case users import both Recast
/// and STL.
pub const rcNewTag = extern struct {};

/// Signed to avoid warnings when comparing to int loop indexes, and common error with comparing to zero.
/// MSVC2010 has a bug where ssize_t is unsigned (!!!).
pub const rcSizeType = isize;

pub fn rcVectorBase(comptime T: type, comptime H: rcAllocHint) type {
    return extern struct {
        const Self = @This();

        m_size: rcSizeType,
        m_cap: rcSizeType,
        m_data: [*c]T,

        /// Constructs a T at the give address with either the copy constructor or the default.
        pub extern fn construct_and_set(p: [*c]T, v: *const T) void;
        // syntax errors:
        // pub fn construct(p: [*c]T) void {
        // ;
        // }
        //
        pub extern fn construct_range(begin: [*c]T, end: [*c]T) void;
        pub extern fn construct_range_and_set(begin: [*c]T, end: [*c]T, value: *const T) void;
        pub extern fn copy_range(dst: [*c]T, begin: [*c]const T, end: [*c]const T) void;
        pub extern fn destroy_range(self: *Self, begin: rcSizeType, end: rcSizeType) void;
        /// Creates an array of the given size, copies all of this vector's data into it, and returns it.
        pub extern fn allocate_and_copy(self: *Self, size: rcSizeType) [*c]T;
        pub extern fn resize_impl(self: *Self, size: rcSizeType, value: [*c]const T) void;
        /// Requires: min_capacity > m_cap.
        pub extern fn get_new_capacity(self: *Self, min_capacity: rcSizeType) rcSizeType;
        pub const size_type = rcSizeType;

        pub const value_type = T;

        /// Unlike in std::vector, we return a bool to indicate whether the alloc was successful.
        pub extern fn reserve(self: *Self, size: rcSizeType) bool;
        pub fn assign(self: *Self, count: rcSizeType, value: *const T) void {
            self.clear();
            self.resize(count, value);
        }
        pub extern fn assign_range(self: *Self, begin: [*c]const T, end: [*c]const T) void;
        pub fn resize(self: *Self, size: rcSizeType) void {
            self.resize_impl(size, 0);
        }
        pub fn resize_and_set(self: *Self, size: rcSizeType, value: *const T) void {
            self.resize_impl(size, &value);
        }
        /// Not implemented as resize(0) because resize requires T to be default-constructible.
        pub extern fn clear(self: *Self) void;
        pub extern fn push_back(self: *Self, value: *const T) void;
        // syntax errors:
        // pub fn pop_back(self: *Self) void {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(self.m_size > @as(rcSizeType, @intCast(0)))) or (((_assert(&"\"m_size > 0\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(143))); 0)) != 0)));
        // ;
        // } else  if (!(self.m_size > @as(rcSizeType, @intCast(0)))) {
        // (failFunc.*)(&"\"m_size > 0\"", &"\"RecastAlloc.h\"", 143);
        // }};
        // ;
        // 0=0=UnresolvedMemberExpr().deinit();
        // self.m_size -= 1;
        // }
        //
        pub fn size(self: *const Self) rcSizeType {
            return self.m_size;
        }
        pub fn capacity(self: *const Self) rcSizeType {
            return self.m_cap;
        }
        pub fn empty(self: *const Self) bool {
            return self.size() == 0;
        }
        // syntax errors:
        // pub fn get(self: *const Self, i: rcSizeType) *const T {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(i >= @as(rcSizeType, @intCast(0)) and i < self.m_size)) or (((_assert(&"\"i >= 0 && i < m_size\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(149))); 0)) != 0)));
        // ;
        // } else  if (!(i >= @as(rcSizeType, @intCast(0)) and i < self.m_size)) {
        // (failFunc.*)(&"\"i >= 0 && i < m_size\"", &"\"RecastAlloc.h\"", 149);
        // }};
        // ;
        // return self.m_data[i];
        // }
        //
        // syntax errors:
        // pub fn getPtr(self: *Self, i: rcSizeType) *T {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(i >= @as(rcSizeType, @intCast(0)) and i < self.m_size)) or (((_assert(&"\"i >= 0 && i < m_size\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(150))); 0)) != 0)));
        // ;
        // } else  if (!(i >= @as(rcSizeType, @intCast(0)) and i < self.m_size)) {
        // (failFunc.*)(&"\"i >= 0 && i < m_size\"", &"\"RecastAlloc.h\"", 150);
        // }};
        // ;
        // return self.m_data[i];
        // }
        //
        // syntax errors:
        // pub fn front(self: *const Self) *const T {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(((self.m_size)) != 0)) or (((_assert(&"\"m_size\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(152))); 0)) != 0)));
        // ;
        // } else  if (!(((self.m_size)) != 0)) {
        // (failFunc.*)(&"\"m_size\"", &"\"RecastAlloc.h\"", 152);
        // }};
        // ;
        // return self.m_data[0];
        // }
        //
        // syntax errors:
        // pub fn front__Overload2(self: *Self) *T {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(((self.m_size)) != 0)) or (((_assert(&"\"m_size\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(153))); 0)) != 0)));
        // ;
        // } else  if (!(((self.m_size)) != 0)) {
        // (failFunc.*)(&"\"m_size\"", &"\"RecastAlloc.h\"", 153);
        // }};
        // ;
        // return self.m_data[0];
        // }
        //
        // syntax errors:
        // pub fn back(self: *const Self) *const T {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(((self.m_size)) != 0)) or (((_assert(&"\"m_size\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(154))); 0)) != 0)));
        // ;
        // } else  if (!(((self.m_size)) != 0)) {
        // (failFunc.*)(&"\"m_size\"", &"\"RecastAlloc.h\"", 154);
        // }};
        // ;
        // return self.m_data[self.m_size - @as(rcSizeType, @intCast(1))];
        // }
        //
        // syntax errors:
        // pub fn back__Overload2(self: *Self) *T {
        // {
        // var failFunc: [*c]rcAssertFailFunc = rcAssertFailGetCustom();
        //  if (failFunc == null) {
        // _ = (((!!(((self.m_size)) != 0)) or (((_assert(&"\"m_size\"", &"\"RecastAlloc.h\"", @as(c_uint, @intCast(155))); 0)) != 0)));
        // ;
        // } else  if (!(((self.m_size)) != 0)) {
        // (failFunc.*)(&"\"m_size\"", &"\"RecastAlloc.h\"", 155);
        // }};
        // ;
        // return self.m_data[self.m_size - @as(rcSizeType, @intCast(1))];
        // }
        //
        pub fn data(self: *const Self) [*c]const T {
            return self.m_data;
        }
        pub fn data__Overload2(self: *Self) [*c]T {
            return self.m_data;
        }
        pub fn begin(self: *Self) [*c]T {
            return self.m_data;
        }
        pub fn end(self: *Self) [*c]T {
            return self.m_data + self.m_size;
        }
        pub fn begin__Overload2(self: *const Self) [*c]const T {
            return self.m_data;
        }
        pub fn end__Overload2(self: *const Self) [*c]const T {
            return self.m_data + self.m_size;
        }
        pub extern fn swap(self: *Self, other: *rcVectorBase(T, H)) void;
        /// Explicitly deleted.
        pub extern fn copyFrom(self: *Self, other: *const rcVectorBase(T, H)) *rcVectorBase(T, H);
    };
}

pub fn rcTempVector(comptime T: type) type {
    return extern struct {
        const Self = @This();

        pub const Base = rcVectorBase(T, RC_ALLOC_TEMP);
    };
}

pub fn rcPermVector(comptime T: type) type {
    return extern struct {
        const Self = @This();

        pub const Base = rcVectorBase(T, RC_ALLOC_PERM);
    };
}

/// Legacy class. Prefer rcVector
///<int
///>.
pub const rcIntArray = extern struct {
    m_impl: rcTempVector(c_int),

    extern fn _1_rcIntArray_init_(self: *rcIntArray) void;
    pub const init = _1_rcIntArray_init_;

    extern fn _2_rcIntArray_init_(self: *rcIntArray, n: c_int) void;
    pub const init2 = _2_rcIntArray_init_;

    pub fn push(self: *rcIntArray, item: c_int) void {
        self.push_back(item);
    }
    pub fn resize(self: *rcIntArray, size: c_int) void {
        self.resize(@as(rcSizeType, @intCast(size)));
    }
    pub fn clear(self: *rcIntArray) void {
        self.clear();
    }
    pub fn pop(self: *rcIntArray) c_int {
        var v: c_int = self.back();
        self.pop_back();
        return v;
    }
    pub fn size(self: *const rcIntArray) c_int {
        return;
    }
    pub fn getPtr(self: *rcIntArray, index: c_int) *c_int {
        return @as(rcVectorBase(c_int, RC_ALLOC_TEMP), self.m_impl).getPtr(@as(rcSizeType, @intCast(index))).*;
    }
    pub fn get(self: *const rcIntArray, index: c_int) c_int {
        return @as(rcVectorBase(c_int, RC_ALLOC_TEMP), self.m_impl).get(@as(rcSizeType, @intCast(index)));
    }
};

pub fn rcScopedDelete(comptime T: anytype) type {
    return extern struct {
        const Self = @This();

        ptr: [*c]T,

        pub extern fn copyFrom(self: *Self, __arg0: *const rcScopedDelete(T)) *rcScopedDelete(T);
    };
}
