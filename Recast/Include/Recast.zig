// auto generated by c2z
const std = @import("std");
//const cpp = @import("cpp");

extern const _1_RC_PI_: *const f32;
pub const RC_PI = _1_RC_PI_;

/// Used to ignore unused function parameters and silence any compiler warnings.
pub fn rcIgnoreUnused(comptime T: anytype, arg_0: *const T) void {
    _ = arg_0; // autofix
}

/// Recast log categories.
/// @see rcContext
pub const rcLogCategory = extern struct {
    bits: c_int = 0,

    /// A progress log entry.
    pub const RC_LOG_PROGRESS: rcLogCategory = .{ .bits = @as(c_uint, @intCast(1)) };
    /// A warning log entry.
    pub const RC_LOG_WARNING: rcLogCategory = .{ .bits = rcLogCategory.RC_LOG_PROGRESS.bits + 1 };
    /// An error log entry.
    pub const RC_LOG_ERROR: rcLogCategory = .{ .bits = rcLogCategory.RC_LOG_PROGRESS.bits + 2 };

    // pub usingnamespace cpp.FlagsMixin(rcLogCategory);
};

/// Recast performance timer categories.
/// @see rcContext
pub const rcTimerLabel = extern struct {
    bits: c_int = 0,

    /// The user defined total time of the build.
    pub const RC_TIMER_TOTAL: rcTimerLabel = .{ .bits = 0 };
    /// A user defined build time.
    pub const RC_TIMER_TEMP: rcTimerLabel = .{ .bits = 1 };
    /// The time to rasterize the triangles. (See: #rcRasterizeTriangle)
    pub const RC_TIMER_RASTERIZE_TRIANGLES: rcTimerLabel = .{ .bits = 2 };
    /// The time to build the compact heightfield. (See: #rcBuildCompactHeightfield)
    pub const RC_TIMER_BUILD_COMPACTHEIGHTFIELD: rcTimerLabel = .{ .bits = 3 };
    /// The total time to build the contours. (See: #rcBuildContours)
    pub const RC_TIMER_BUILD_CONTOURS: rcTimerLabel = .{ .bits = 4 };
    /// The time to trace the boundaries of the contours. (See: #rcBuildContours)
    pub const RC_TIMER_BUILD_CONTOURS_TRACE: rcTimerLabel = .{ .bits = 5 };
    /// The time to simplify the contours. (See: #rcBuildContours)
    pub const RC_TIMER_BUILD_CONTOURS_SIMPLIFY: rcTimerLabel = .{ .bits = 6 };
    /// The time to filter ledge spans. (See: #rcFilterLedgeSpans)
    pub const RC_TIMER_FILTER_BORDER: rcTimerLabel = .{ .bits = 7 };
    /// The time to filter low height spans. (See: #rcFilterWalkableLowHeightSpans)
    pub const RC_TIMER_FILTER_WALKABLE: rcTimerLabel = .{ .bits = 8 };
    /// The time to apply the median filter. (See: #rcMedianFilterWalkableArea)
    pub const RC_TIMER_MEDIAN_AREA: rcTimerLabel = .{ .bits = 9 };
    /// The time to filter low obstacles. (See: #rcFilterLowHangingWalkableObstacles)
    pub const RC_TIMER_FILTER_LOW_OBSTACLES: rcTimerLabel = .{ .bits = 10 };
    /// The time to build the polygon mesh. (See: #rcBuildPolyMesh)
    pub const RC_TIMER_BUILD_POLYMESH: rcTimerLabel = .{ .bits = 11 };
    /// The time to merge polygon meshes. (See: #rcMergePolyMeshes)
    pub const RC_TIMER_MERGE_POLYMESH: rcTimerLabel = .{ .bits = 12 };
    /// The time to erode the walkable area. (See: #rcErodeWalkableArea)
    pub const RC_TIMER_ERODE_AREA: rcTimerLabel = .{ .bits = 13 };
    /// The time to mark a box area. (See: #rcMarkBoxArea)
    pub const RC_TIMER_MARK_BOX_AREA: rcTimerLabel = .{ .bits = 14 };
    /// The time to mark a cylinder area. (See: #rcMarkCylinderArea)
    pub const RC_TIMER_MARK_CYLINDER_AREA: rcTimerLabel = .{ .bits = 15 };
    /// The time to mark a convex polygon area. (See: #rcMarkConvexPolyArea)
    pub const RC_TIMER_MARK_CONVEXPOLY_AREA: rcTimerLabel = .{ .bits = 16 };
    /// The total time to build the distance field. (See: #rcBuildDistanceField)
    pub const RC_TIMER_BUILD_DISTANCEFIELD: rcTimerLabel = .{ .bits = 17 };
    /// The time to build the distances of the distance field. (See: #rcBuildDistanceField)
    pub const RC_TIMER_BUILD_DISTANCEFIELD_DIST: rcTimerLabel = .{ .bits = 18 };
    /// The time to blur the distance field. (See: #rcBuildDistanceField)
    pub const RC_TIMER_BUILD_DISTANCEFIELD_BLUR: rcTimerLabel = .{ .bits = 19 };
    /// The total time to build the regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
    pub const RC_TIMER_BUILD_REGIONS: rcTimerLabel = .{ .bits = 20 };
    /// The total time to apply the watershed algorithm. (See: #rcBuildRegions)
    pub const RC_TIMER_BUILD_REGIONS_WATERSHED: rcTimerLabel = .{ .bits = 21 };
    /// The time to expand regions while applying the watershed algorithm. (See: #rcBuildRegions)
    pub const RC_TIMER_BUILD_REGIONS_EXPAND: rcTimerLabel = .{ .bits = 22 };
    /// The time to flood regions while applying the watershed algorithm. (See: #rcBuildRegions)
    pub const RC_TIMER_BUILD_REGIONS_FLOOD: rcTimerLabel = .{ .bits = 23 };
    /// The time to filter out small regions. (See: #rcBuildRegions, #rcBuildRegionsMonotone)
    pub const RC_TIMER_BUILD_REGIONS_FILTER: rcTimerLabel = .{ .bits = 24 };
    /// The time to build heightfield layers. (See: #rcBuildHeightfieldLayers)
    pub const RC_TIMER_BUILD_LAYERS: rcTimerLabel = .{ .bits = 25 };
    /// The time to build the polygon mesh detail. (See: #rcBuildPolyMeshDetail)
    pub const RC_TIMER_BUILD_POLYMESHDETAIL: rcTimerLabel = .{ .bits = 26 };
    /// The time to merge polygon mesh details. (See: #rcMergePolyMeshDetails)
    pub const RC_TIMER_MERGE_POLYMESHDETAIL: rcTimerLabel = .{ .bits = 27 };
    /// The maximum number of timers.  (Used for iterating timers.)
    pub const RC_MAX_TIMERS: rcTimerLabel = .{ .bits = 28 };

    // pub usingnamespace cpp.FlagsMixin(rcTimerLabel);
};

/// Provides an interface for optional logging and performance tracking of the Recast
/// build process.
///
/// This class does not provide logging or timer functionality on its
/// own.  Both must be provided by a concrete implementation
/// by overriding the protected member functions.  Also, this class does not
/// provide an interface for extracting log messages. (Only adding them.)
/// So concrete implementations must provide one.
///
/// If no logging or timers are required, just pass an instance of this
/// class through the Recast build process.
///
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcContext = extern struct {
    vtable: *const anyopaque,

    /// True if logging is enabled.
    m_logEnabled: bool,
    /// True if the performance timers are enabled.
    m_timerEnabled: bool,

    /// Constructor.
    ///  @param[in] state 	TRUE if the logging and performance timers should be enabled.  [Default: true]
    extern fn _1_rcContext_init_(self: *rcContext, state: bool) void;
    pub const init = _1_rcContext_init_;

    extern fn _1_rcContext_deinit_(self: *rcContext) void;
    pub const deinit = _1_rcContext_deinit_;

    extern fn _1_rcContext_enableLog_(self: *rcContext, state: bool) void;
    /// Enables or disables logging.
    ///  @param[in] state 	TRUE if logging should be enabled.
    pub const enableLog = _1_rcContext_enableLog_;

    extern fn _1_rcContext_resetLog_(self: *rcContext) void;
    /// Clears all log entries.
    pub const resetLog = _1_rcContext_resetLog_;

    extern fn _1_rcContext_enableTimer_(self: *rcContext, state: bool) void;
    /// Enables or disables the performance timers.
    ///  @param[in] state 	TRUE if timers should be enabled.
    pub const enableTimer = _1_rcContext_enableTimer_;

    extern fn _1_rcContext_resetTimers_(self: *rcContext) void;
    /// Clears all performance timers. (Resets all to unused.)
    pub const resetTimers = _1_rcContext_resetTimers_;

    extern fn _1_rcContext_startTimer_(self: *rcContext, label: rcTimerLabel) void;
    /// Starts the specified performance timer.
    /// @param[in] label 	The category of the timer.
    pub const startTimer = _1_rcContext_startTimer_;

    extern fn _1_rcContext_stopTimer_(self: *rcContext, label: rcTimerLabel) void;
    /// Stops the specified performance timer.
    /// @param[in] label 	The category of the timer.
    pub const stopTimer = _1_rcContext_stopTimer_;

    extern fn _1_rcContext_getAccumulatedTime_(self: *const rcContext, label: rcTimerLabel) c_int;
    /// Returns the total accumulated time of the specified performance timer.
    /// @param[in] label 	The category of the timer.
    /// @see The accumulated time of the timer, or -1 if timers are disabled or the timer has never been started.
    pub const getAccumulatedTime = _1_rcContext_getAccumulatedTime_;
};

/// A helper to first start a timer and then stop it when this helper goes out of scope.
/// @see rcContext
pub const rcScopedTimer = extern struct {
    m_ctx: *const rcContext,
    m_label: rcTimerLabel,

    /// Constructs an instance and starts the timer.
    ///  @param[in] ctx 		The context to use.
    ///  @param[in] label 	The category of the timer.
    extern fn _1_rcScopedTimer_init_(self: *rcScopedTimer, ctx: [*c]rcContext, label: rcTimerLabel) void;
    pub const init = _1_rcScopedTimer_init_;

    extern fn _1_rcScopedTimer_deinit_(self: *rcScopedTimer) void;
    pub const deinit = _1_rcScopedTimer_deinit_;
};

/// Specifies a configuration to use when performing Recast builds.
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcConfig = extern struct {
    /// The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
    width: c_int,
    /// The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
    height: c_int,
    /// The width/height size of tile's on the xz-plane. [Limit: >= 0] [Units: vx]
    tileSize: c_int,
    /// The size of the non-navigable border around the heightfield. [Limit: >=0] [Units: vx]
    borderSize: c_int,
    /// The xz-plane cell size to use for fields. [Limit: > 0] [Units: wu]
    cs: f32,
    /// The y-axis cell size to use for fields. [Limit: > 0] [Units: wu]
    ch: f32,
    /// The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
    bmin: [3]f32,
    /// The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
    bmax: [3]f32,
    /// The maximum slope that is considered walkable. [Limits: 0
    ///<
    ///= value
    ///<
    /// 90] [Units: Degrees]
    walkableSlopeAngle: f32,
    /// Minimum floor to 'ceiling' height that will still allow the floor area to
    /// be considered walkable. [Limit: >= 3] [Units: vx]
    walkableHeight: c_int,
    /// Maximum ledge height that is considered to still be traversable. [Limit: >=0] [Units: vx]
    walkableClimb: c_int,
    /// The distance to erode/shrink the walkable area of the heightfield away from
    /// obstructions.  [Limit: >=0] [Units: vx]
    walkableRadius: c_int,
    /// The maximum allowed length for contour edges along the border of the mesh. [Limit: >=0] [Units: vx]
    maxEdgeLen: c_int,
    /// The maximum distance a simplified contour's border edges should deviate
    /// the original raw contour. [Limit: >=0] [Units: vx]
    maxSimplificationError: f32,
    /// The minimum number of cells allowed to form isolated island areas. [Limit: >=0] [Units: vx]
    minRegionArea: c_int,
    /// Any regions with a span count smaller than this value will, if possible,
    /// be merged with larger regions. [Limit: >=0] [Units: vx]
    mergeRegionArea: c_int,
    /// The maximum number of vertices allowed for polygons generated during the
    /// contour to polygon conversion process. [Limit: >= 3]
    maxVertsPerPoly: c_int,
    /// Sets the sampling distance to use when generating the detail mesh.
    /// (For height detail only.) [Limits: 0 or >= 0.9] [Units: wu]
    detailSampleDist: f32,
    /// The maximum distance the detail mesh surface should deviate from heightfield
    /// data. (For height detail only.) [Limit: >=0] [Units: wu]
    detailSampleMaxError: f32,
};

extern const _1_RC_SPAN_HEIGHT_BITS_: *const c_int;
pub const RC_SPAN_HEIGHT_BITS = _1_RC_SPAN_HEIGHT_BITS_;

extern const _1_RC_SPAN_MAX_HEIGHT_: *const c_int;
pub const RC_SPAN_MAX_HEIGHT = _1_RC_SPAN_MAX_HEIGHT_;

extern const _1_RC_SPANS_PER_POOL_: *const c_int;
pub const RC_SPANS_PER_POOL = _1_RC_SPANS_PER_POOL_;

/// Represents a span in a heightfield.
/// @see rcHeightfield
pub const rcSpan = extern struct {
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// The lower limit of the span. [Limit:
        ///<
        /// #smax]
        smin: u13, // 13 bits
        /// The upper limit of the span. [Limit:
        ///<
        ///= #RC_SPAN_MAX_HEIGHT]
        smax: u13, // 26 bits
        /// The area id assigned to the span.
        area: u6, // 32 bits
    },

    /// The next span higher up in column.
    next: [*c]rcSpan,
};

/// A memory pool used for quick allocation of spans within a heightfield.
/// @see rcHeightfield
pub const rcSpanPool = extern struct {
    /// The next span pool.
    next: [*c]rcSpanPool,
    /// Array of spans in the pool.
    items: [2048]rcSpan,
};

/// A dynamic heightfield representing obstructed space.
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcHeightfield = extern struct {
    /// The width of the heightfield. (Along the x-axis in cell units.)
    width: c_int,
    /// The height of the heightfield. (Along the z-axis in cell units.)
    height: c_int,
    /// The minimum bounds in world space. [(x, y, z)]
    bmin: [3]f32,
    /// The maximum bounds in world space. [(x, y, z)]
    bmax: [3]f32,
    /// The size of each cell. (On the xz-plane.)
    cs: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    ch: f32,
    /// Heightfield of spans (width*height).
    spans: [*c][*c]rcSpan,
    /// Linked list of span pools.
    pools: [*c]rcSpanPool,
    /// The next free span.
    freelist: [*c]rcSpan,

    extern fn _1_rcHeightfield_init_(self: *rcHeightfield) void;
    pub const init = _1_rcHeightfield_init_;

    extern fn _1_rcHeightfield_deinit_(self: *rcHeightfield) void;
    pub const deinit = _1_rcHeightfield_deinit_;
};

/// Provides information on the content of a cell column in a compact heightfield.
pub const rcCompactCell = extern struct {
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Index to the first span in the column.
        index: u24, // 24 bits
        /// Number of spans in the column.
        count: u8, // 32 bits
    },
};

/// Represents a span of unobstructed space within a compact heightfield.
pub const rcCompactSpan = extern struct {
    /// The lower extent of the span. (Measured from the heightfield's base.)
    y: c_ushort,
    /// The id of the region the span belongs to. (Or zero if not in a region.)
    reg: c_ushort,
    bitfield_1: packed struct(u32) {
        // NOTE: Bitfield generation not guaranteed to work on all platforms, use with caution.

        /// Packed neighbor connection data.
        con: u24, // 24 bits
        /// The height of the span.  (Measured from #y.)
        h: u8, // 32 bits
    },
};

/// A compact, static heightfield representing unobstructed space.
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcCompactHeightfield = extern struct {
    /// The width of the heightfield. (Along the x-axis in cell units.)
    width: c_int,
    /// The height of the heightfield. (Along the z-axis in cell units.)
    height: c_int,
    /// The number of spans in the heightfield.
    spanCount: c_int,
    /// The walkable height used during the build of the field.  (See: rcConfig::walkableHeight)
    walkableHeight: c_int,
    /// The walkable climb used during the build of the field. (See: rcConfig::walkableClimb)
    walkableClimb: c_int,
    /// The AABB border size used during the build of the field. (See: rcConfig::borderSize)
    borderSize: c_int,
    /// The maximum distance value of any span within the field.
    maxDistance: c_ushort,
    /// The maximum region id of any span within the field.
    maxRegions: c_ushort,
    /// The minimum bounds in world space. [(x, y, z)]
    bmin: [3]f32,
    /// The maximum bounds in world space. [(x, y, z)]
    bmax: [3]f32,
    /// The size of each cell. (On the xz-plane.)
    cs: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    ch: f32,
    /// Array of cells. [Size: #width*#height]
    cells: [*c]rcCompactCell,
    /// Array of spans. [Size: #spanCount]
    spans: [*c]rcCompactSpan,
    /// Array containing border distance data. [Size: #spanCount]
    dist: [*c]c_ushort,
    /// Array containing area id data. [Size: #spanCount]
    areas: [*c]u8,

    extern fn _1_rcCompactHeightfield_init_(self: *rcCompactHeightfield) void;
    pub const init = _1_rcCompactHeightfield_init_;

    extern fn _1_rcCompactHeightfield_deinit_(self: *rcCompactHeightfield) void;
    pub const deinit = _1_rcCompactHeightfield_deinit_;
};

/// Represents a heightfield layer within a layer set.
/// @see rcHeightfieldLayerSet
pub const rcHeightfieldLayer = extern struct {
    /// The minimum bounds in world space. [(x, y, z)]
    bmin: [3]f32,
    /// The maximum bounds in world space. [(x, y, z)]
    bmax: [3]f32,
    /// The size of each cell. (On the xz-plane.)
    cs: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    ch: f32,
    /// The width of the heightfield. (Along the x-axis in cell units.)
    width: c_int,
    /// The height of the heightfield. (Along the z-axis in cell units.)
    height: c_int,
    /// The minimum x-bounds of usable data.
    minx: c_int,
    /// The maximum x-bounds of usable data.
    maxx: c_int,
    /// The minimum y-bounds of usable data. (Along the z-axis.)
    miny: c_int,
    /// The maximum y-bounds of usable data. (Along the z-axis.)
    maxy: c_int,
    /// The minimum height bounds of usable data. (Along the y-axis.)
    hmin: c_int,
    /// The maximum height bounds of usable data. (Along the y-axis.)
    hmax: c_int,
    /// The heightfield. [Size: width * height]
    heights: [*c]u8,
    /// Area ids. [Size: Same as #heights]
    areas: [*c]u8,
    /// Packed neighbor connection information. [Size: Same as #heights]
    cons: [*c]u8,
};

/// Represents a set of heightfield layers.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocHeightfieldLayerSet, rcFreeHeightfieldLayerSet
pub const rcHeightfieldLayerSet = extern struct {
    /// The layers in the set. [Size: #nlayers]
    layers: [*c]rcHeightfieldLayer,
    /// The number of layers in the set.
    nlayers: c_int,

    extern fn _1_rcHeightfieldLayerSet_init_(self: *rcHeightfieldLayerSet) void;
    pub const init = _1_rcHeightfieldLayerSet_init_;

    extern fn _1_rcHeightfieldLayerSet_deinit_(self: *rcHeightfieldLayerSet) void;
    pub const deinit = _1_rcHeightfieldLayerSet_deinit_;
};

/// Represents a simple, non-overlapping contour in field space.
pub const rcContour = extern struct {
    /// Simplified contour vertex and connection data. [Size: 4 * #nverts]
    verts: [*c]c_int,
    /// The number of vertices in the simplified contour.
    nverts: c_int,
    /// Raw contour vertex and connection data. [Size: 4 * #nrverts]
    rverts: [*c]c_int,
    /// The number of vertices in the raw contour.
    nrverts: c_int,
    /// The region id of the contour.
    reg: c_ushort,
    /// The area id of the contour.
    area: u8,
};

/// Represents a group of related contours.
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcContourSet = extern struct {
    /// An array of the contours in the set. [Size: #nconts]
    conts: [*c]rcContour,
    /// The number of contours in the set.
    nconts: c_int,
    /// The minimum bounds in world space. [(x, y, z)]
    bmin: [3]f32,
    /// The maximum bounds in world space. [(x, y, z)]
    bmax: [3]f32,
    /// The size of each cell. (On the xz-plane.)
    cs: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    ch: f32,
    /// The width of the set. (Along the x-axis in cell units.)
    width: c_int,
    /// The height of the set. (Along the z-axis in cell units.)
    height: c_int,
    /// The AABB border size used to generate the source data from which the contours were derived.
    borderSize: c_int,
    /// The max edge error that this contour set was simplified with.
    maxError: f32,

    extern fn _1_rcContourSet_init_(self: *rcContourSet) void;
    pub const init = _1_rcContourSet_init_;

    extern fn _1_rcContourSet_deinit_(self: *rcContourSet) void;
    pub const deinit = _1_rcContourSet_deinit_;
};

/// Represents a polygon mesh suitable for use in building a navigation mesh.
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcPolyMesh = extern struct {
    /// The mesh vertices. [Form: (x, y, z) * #nverts]
    verts: [*c]c_ushort,
    /// Polygon and neighbor data. [Length: #maxpolys * 2 * #nvp]
    polys: [*c]c_ushort,
    /// The region id assigned to each polygon. [Length: #maxpolys]
    regs: [*c]c_ushort,
    /// The user defined flags for each polygon. [Length: #maxpolys]
    flags: [*c]c_ushort,
    /// The area id assigned to each polygon. [Length: #maxpolys]
    areas: [*c]u8,
    /// The number of vertices.
    nverts: c_int,
    /// The number of polygons.
    npolys: c_int,
    /// The number of allocated polygons.
    maxpolys: c_int,
    /// The maximum number of vertices per polygon.
    nvp: c_int,
    /// The minimum bounds in world space. [(x, y, z)]
    bmin: [3]f32,
    /// The maximum bounds in world space. [(x, y, z)]
    bmax: [3]f32,
    /// The size of each cell. (On the xz-plane.)
    cs: f32,
    /// The height of each cell. (The minimum increment along the y-axis.)
    ch: f32,
    /// The AABB border size used to generate the source data from which the mesh was derived.
    borderSize: c_int,
    /// The max error of the polygon edges in the mesh.
    maxEdgeError: f32,

    extern fn _1_rcPolyMesh_init_(self: *rcPolyMesh) void;
    pub const init = _1_rcPolyMesh_init_;

    extern fn _1_rcPolyMesh_deinit_(self: *rcPolyMesh) void;
    pub const deinit = _1_rcPolyMesh_deinit_;
};

/// Contains triangle meshes that represent detailed height data associated
/// with the polygons in its associated polygon mesh object.
/// @UntranspiledVerbatimLineCommentCommand recast
pub const rcPolyMeshDetail = extern struct {
    /// The sub-mesh data. [Size: 4*#nmeshes]
    meshes: [*c]c_uint,
    /// The mesh vertices. [Size: 3*#nverts]
    verts: [*c]f32,
    /// The mesh triangles. [Size: 4*#ntris]
    tris: [*c]u8,
    /// The number of sub-meshes defined by #meshes.
    nmeshes: c_int,
    /// The number of vertices in #verts.
    nverts: c_int,
    /// The number of triangles in #tris.
    ntris: c_int,

    extern fn _1_rcPolyMeshDetail_init_(self: *rcPolyMeshDetail) void;
    pub const init = _1_rcPolyMeshDetail_init_;
};

extern fn _1_rcAllocHeightfield_() [*c]rcHeightfield;
/// Allocates a heightfield object using the Recast allocator.
/// @see A heightfield that is ready for initialization, or null on failure.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcCreateHeightfield, rcFreeHeightField
pub const rcAllocHeightfield = _1_rcAllocHeightfield_;

extern fn _1_rcFreeHeightField_(heightfield: [*c]rcHeightfield) void;
/// Frees the specified heightfield object using the Recast allocator.
/// @param[in] heightfield 	A heightfield allocated using #rcAllocHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocHeightfield
pub const rcFreeHeightField = _1_rcFreeHeightField_;

extern fn _1_rcAllocCompactHeightfield_() [*c]rcCompactHeightfield;
/// Allocates a compact heightfield object using the Recast allocator.
/// @see A compact heightfield that is ready for initialization, or null on failure.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcBuildCompactHeightfield, rcFreeCompactHeightfield
pub const rcAllocCompactHeightfield = _1_rcAllocCompactHeightfield_;

extern fn _1_rcFreeCompactHeightfield_(compactHeightfield: [*c]rcCompactHeightfield) void;
/// Frees the specified compact heightfield object using the Recast allocator.
/// @param[in] compactHeightfield 		A compact heightfield allocated using #rcAllocCompactHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocCompactHeightfield
pub const rcFreeCompactHeightfield = _1_rcFreeCompactHeightfield_;

extern fn _1_rcAllocHeightfieldLayerSet_() [*c]rcHeightfieldLayerSet;
/// Allocates a heightfield layer set using the Recast allocator.
/// @see A heightfield layer set that is ready for initialization, or null on failure.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcBuildHeightfieldLayers, rcFreeHeightfieldLayerSet
pub const rcAllocHeightfieldLayerSet = _1_rcAllocHeightfieldLayerSet_;

extern fn _1_rcFreeHeightfieldLayerSet_(layerSet: [*c]rcHeightfieldLayerSet) void;
/// Frees the specified heightfield layer set using the Recast allocator.
/// @param[in] layerSet 	A heightfield layer set allocated using #rcAllocHeightfieldLayerSet
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocHeightfieldLayerSet
pub const rcFreeHeightfieldLayerSet = _1_rcFreeHeightfieldLayerSet_;

extern fn _1_rcAllocContourSet_() [*c]rcContourSet;
/// Allocates a contour set object using the Recast allocator.
/// @see A contour set that is ready for initialization, or null on failure.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcBuildContours, rcFreeContourSet
pub const rcAllocContourSet = _1_rcAllocContourSet_;

extern fn _1_rcFreeContourSet_(contourSet: [*c]rcContourSet) void;
/// Frees the specified contour set using the Recast allocator.
/// @param[in] contourSet 	A contour set allocated using #rcAllocContourSet
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocContourSet
pub const rcFreeContourSet = _1_rcFreeContourSet_;

extern fn _1_rcAllocPolyMesh_() [*c]rcPolyMesh;
/// Allocates a polygon mesh object using the Recast allocator.
/// @see A polygon mesh that is ready for initialization, or null on failure.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcBuildPolyMesh, rcFreePolyMesh
pub const rcAllocPolyMesh = _1_rcAllocPolyMesh_;

extern fn _1_rcFreePolyMesh_(polyMesh: [*c]rcPolyMesh) void;
/// Frees the specified polygon mesh using the Recast allocator.
/// @param[in] polyMesh 	A polygon mesh allocated using #rcAllocPolyMesh
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocPolyMesh
pub const rcFreePolyMesh = _1_rcFreePolyMesh_;

extern fn _1_rcAllocPolyMeshDetail_() [*c]rcPolyMeshDetail;
/// Allocates a detail mesh object using the Recast allocator.
/// @see A detail mesh that is ready for initialization, or null on failure.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcBuildPolyMeshDetail, rcFreePolyMeshDetail
pub const rcAllocPolyMeshDetail = _1_rcAllocPolyMeshDetail_;

extern fn _1_rcFreePolyMeshDetail_(detailMesh: [*c]rcPolyMeshDetail) void;
/// Frees the specified detail mesh using the Recast allocator.
/// @param[in] detailMesh 	A detail mesh allocated using #rcAllocPolyMeshDetail
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @see rcAllocPolyMeshDetail
pub const rcFreePolyMeshDetail = _1_rcFreePolyMeshDetail_;

extern const _1_RC_BORDER_REG_: *const c_ushort;
pub const RC_BORDER_REG = _1_RC_BORDER_REG_;

extern const _1_RC_MULTIPLE_REGS_: *const c_ushort;
pub const RC_MULTIPLE_REGS = _1_RC_MULTIPLE_REGS_;

extern const _1_RC_BORDER_VERTEX_: *const c_int;
pub const RC_BORDER_VERTEX = _1_RC_BORDER_VERTEX_;

extern const _1_RC_AREA_BORDER_: *const c_int;
pub const RC_AREA_BORDER = _1_RC_AREA_BORDER_;

/// Contour build flags.
/// @see rcBuildContours
pub const rcBuildContoursFlags = extern struct {
    bits: c_int = 0,

    /// Tessellate solid (impassable) edges during contour simplification.
    pub const RC_CONTOUR_TESS_WALL_EDGES: rcBuildContoursFlags = .{ .bits = @as(c_uint, @intCast(1)) };
    /// Tessellate edges between areas during contour simplification.
    pub const RC_CONTOUR_TESS_AREA_EDGES: rcBuildContoursFlags = .{ .bits = @as(c_uint, @intCast(2)) };

    // pub usingnamespace cpp.FlagsMixin(rcBuildContoursFlags);
};

extern const _1_RC_CONTOUR_REG_MASK_: *const c_int;
pub const RC_CONTOUR_REG_MASK = _1_RC_CONTOUR_REG_MASK_;

extern const _1_RC_MESH_NULL_IDX_: *const c_ushort;
pub const RC_MESH_NULL_IDX = _1_RC_MESH_NULL_IDX_;

extern const _1_RC_NULL_AREA_: *const u8;
pub const RC_NULL_AREA = _1_RC_NULL_AREA_;

extern const _1_RC_WALKABLE_AREA_: *const u8;
pub const RC_WALKABLE_AREA = _1_RC_WALKABLE_AREA_;

extern const _1_RC_NOT_CONNECTED_: *const c_int;
pub const RC_NOT_CONNECTED = _1_RC_NOT_CONNECTED_;

/// Swaps the values of the two parameters.
/// @param[in,out] a 	Value A
/// @param[in,out] b 	Value B
pub inline fn rcSwap(comptime T: anytype, a: *T, b: *T) void {
    const t: T = a;
    a = b;
    b = t;
}

/// Returns the minimum of two values.
/// @param[in] a 	Value A
/// @param[in] b 	Value B
/// @see The minimum of the two values.
pub inline fn rcMin(comptime T: anytype, a: T, b: T) T {
    return if (a < b) a else b;
}

/// Returns the maximum of two values.
/// @param[in] a 	Value A
/// @param[in] b 	Value B
/// @see The maximum of the two values.
pub inline fn rcMax(comptime T: anytype, a: T, b: T) T {
    return if (a > b) a else b;
}

/// Returns the absolute value.
/// @param[in] a 	The value.
/// @see The absolute value of the specified value.
pub inline fn rcAbs(comptime T: anytype, a: T) T {
    return if (a < 0) -a else a;
}

/// Returns the square of the value.
/// @param[in] a 	The value.
/// @see The square of the value.
pub inline fn rcSqr(comptime T: anytype, a: T) T {
    return a * a;
}

/// Clamps the value to the specified range.
/// @param[in] value 			The value to clamp.
/// @param[in] minInclusive 	The minimum permitted return value.
/// @param[in] maxInclusive 	The maximum permitted return value.
/// @see The value, clamped to the specified range.
pub inline fn rcClamp(comptime T: anytype, value: T, minInclusive: T, maxInclusive: T) T {
    return if (value < minInclusive) minInclusive else (if (value > maxInclusive) maxInclusive else value);
}

extern fn _1_rcSqrt_(x: f32) f32;
/// Returns the square root of the value.
///  @param[in] x 	The value.
///  @see The square root of the vlaue.
pub const rcSqrt = _1_rcSqrt_;

extern fn _1_rcVcross_(dest: [*c]f32, v1: [*c]const f32, v2: [*c]const f32) void;
/// Derives the cross product of two vectors. (
///@p
/// x
///@p
/// @param[out] dest 	The cross product. [(x, y, z)]
/// @param[in] v1 		A Vector [(x, y, z)]
/// @param[in] v2 		A vector [(x, y, z)]
pub const rcVcross = _1_rcVcross_;

extern fn _1_rcVdot_(v1: [*c]const f32, v2: [*c]const f32) f32;
/// Derives the dot product of two vectors. (
///@p
/// .
///@p
/// @param[in] v1 	A Vector [(x, y, z)]
/// @param[in] v2 	A vector [(x, y, z)]
/// @see The dot product.
pub const rcVdot = _1_rcVdot_;

extern fn _1_rcVmad_(dest: [*c]f32, v1: [*c]const f32, v2: [*c]const f32, s: f32) void;
/// Performs a scaled vector addition. (
///@p
/// + (
///@p
/// *
///@p
/// @param[out] dest 	The result vector. [(x, y, z)]
/// @param[in] v1 		The base vector. [(x, y, z)]
/// @param[in] v2 		The vector to scale and add to
///@p
/// [(x, y, z)]
/// @param[in] s 		The amount to scale
///@p
/// by before adding to
///@p
pub const rcVmad = _1_rcVmad_;

extern fn _1_rcVadd_(dest: [*c]f32, v1: [*c]const f32, v2: [*c]const f32) void;
/// Performs a vector addition. (
///@p
/// +
///@p
/// @param[out] dest 	The result vector. [(x, y, z)]
/// @param[in] v1 		The base vector. [(x, y, z)]
/// @param[in] v2 		The vector to add to
///@p
/// [(x, y, z)]
pub const rcVadd = _1_rcVadd_;

extern fn _1_rcVsub_(dest: [*c]f32, v1: [*c]const f32, v2: [*c]const f32) void;
/// Performs a vector subtraction. (
///@p
/// -
///@p
/// @param[out] dest 	The result vector. [(x, y, z)]
/// @param[in] v1 		The base vector. [(x, y, z)]
/// @param[in] v2 		The vector to subtract from
///@p
/// [(x, y, z)]
pub const rcVsub = _1_rcVsub_;

extern fn _1_rcVmin_(mn: [*c]f32, v: [*c]const f32) void;
/// Selects the minimum value of each element from the specified vectors.
/// @param[in,out] mn 	A vector.  (Will be updated with the result.) [(x, y, z)]
/// @param[in] v 	A vector. [(x, y, z)]
pub const rcVmin = _1_rcVmin_;

extern fn _1_rcVmax_(mx: [*c]f32, v: [*c]const f32) void;
/// Selects the maximum value of each element from the specified vectors.
/// @param[in,out] mx 	A vector.  (Will be updated with the result.) [(x, y, z)]
/// @param[in] v 	A vector. [(x, y, z)]
pub const rcVmax = _1_rcVmax_;

extern fn _1_rcVcopy_(dest: [*c]f32, v: [*c]const f32) void;
/// Performs a vector copy.
/// @param[out] dest 	The result. [(x, y, z)]
/// @param[in] v 		The vector to copy. [(x, y, z)]
pub const rcVcopy = _1_rcVcopy_;

extern fn _1_rcVdist_(v1: [*c]const f32, v2: [*c]const f32) f32;
/// Returns the distance between two points.
/// @param[in] v1 	A point. [(x, y, z)]
/// @param[in] v2 	A point. [(x, y, z)]
/// @see The distance between the two points.
pub const rcVdist = _1_rcVdist_;

extern fn _1_rcVdistSqr_(v1: [*c]const f32, v2: [*c]const f32) f32;
/// Returns the square of the distance between two points.
/// @param[in] v1 	A point. [(x, y, z)]
/// @param[in] v2 	A point. [(x, y, z)]
/// @see The square of the distance between the two points.
pub const rcVdistSqr = _1_rcVdistSqr_;

extern fn _1_rcVnormalize_(v: [*c]f32) void;
/// Normalizes the vector.
/// @param[in,out] v 	The vector to normalize. [(x, y, z)]
pub const rcVnormalize = _1_rcVnormalize_;

extern fn _1_rcCalcBounds_(verts: [*c]const f32, numVerts: c_int, minBounds: [*c]f32, maxBounds: [*c]f32) void;
/// Calculates the bounding box of an array of vertices.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in] verts 		An array of vertices. [(x, y, z) *
///@p
/// @param[in] numVerts 	The number of vertices in the
///@p
/// array.
/// @param[out] minBounds 	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
/// @param[out] maxBounds 	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
pub const rcCalcBounds = _1_rcCalcBounds_;

extern fn _1_rcCalcGridSize_(minBounds: [*c]const f32, maxBounds: [*c]const f32, cellSize: f32, sizeX: [*c]c_int, sizeZ: [*c]c_int) void;
/// Calculates the grid size based on the bounding box and grid cell size.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in] minBounds 	The minimum bounds of the AABB. [(x, y, z)] [Units: wu]
/// @param[in] maxBounds 	The maximum bounds of the AABB. [(x, y, z)] [Units: wu]
/// @param[in] cellSize 	The xz-plane cell size. [Limit: > 0] [Units: wu]
/// @param[out] sizeX 		The width along the x-axis. [Limit: >= 0] [Units: vx]
/// @param[out] sizeZ 		The height along the z-axis. [Limit: >= 0] [Units: vx]
pub const rcCalcGridSize = _1_rcCalcGridSize_;

extern fn _1_rcCreateHeightfield_(context: [*c]rcContext, heightfield: *rcHeightfield, sizeX: c_int, sizeZ: c_int, minBounds: [*c]const f32, maxBounds: [*c]const f32, cellSize: f32, cellHeight: f32) bool;
/// Initializes a new heightfield.
/// See the #rcConfig documentation for more information on the configuration parameters.
///
/// @see rcAllocHeightfield, rcHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 		The build context to use during the operation.
/// @param[in,out] heightfield 	The allocated heightfield to initialize.
/// @param[in] sizeX 		The width of the field along the x-axis. [Limit: >= 0] [Units: vx]
/// @param[in] sizeZ 		The height of the field along the z-axis. [Limit: >= 0] [Units: vx]
/// @param[in] minBounds 	The minimum bounds of the field's AABB. [(x, y, z)] [Units: wu]
/// @param[in] maxBounds 	The maximum bounds of the field's AABB. [(x, y, z)] [Units: wu]
/// @param[in] cellSize 	The xz-plane cell size to use for the field. [Limit: > 0] [Units: wu]
/// @param[in] cellHeight 	The y-axis cell size to use for field. [Limit: > 0] [Units: wu]
/// @see True if the operation completed successfully.
pub const rcCreateHeightfield = _1_rcCreateHeightfield_;

extern fn _1_rcMarkWalkableTriangles_(context: [*c]rcContext, walkableSlopeAngle: f32, verts: [*c]const f32, numVerts: c_int, tris: [*c]const c_int, numTris: c_int, triAreaIDs: [*c]u8) void;
/// Sets the area id of all triangles with a slope below the specified value
/// to #RC_WALKABLE_AREA.
///
/// Only sets the area id's for the walkable triangles.  Does not alter the
/// area id's for un-walkable triangles.
///
/// See the #rcConfig documentation for more information on the configuration parameters.
///
/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] walkableSlopeAngle 	The maximum slope that is considered walkable.
/// 									[Limits: 0
///<
///= value
///<
/// 90] [Units: Degrees]
/// @param[in] verts 				The vertices. [(x, y, z) *
///@p
/// @param[in] numVerts 			The number of vertices.
/// @param[in] tris 				The triangle vertex indices. [(vertA, vertB, vertC) *
///@p
/// @param[in] numTris 				The number of triangles.
/// @param[out] triAreaIDs 			The triangle area ids. [Length: >=
///@p
pub const rcMarkWalkableTriangles = _1_rcMarkWalkableTriangles_;

extern fn _1_rcClearUnwalkableTriangles_(context: [*c]rcContext, walkableSlopeAngle: f32, verts: [*c]const f32, numVerts: c_int, tris: [*c]const c_int, numTris: c_int, triAreaIDs: [*c]u8) void;
/// Sets the area id of all triangles with a slope greater than or equal to the specified value to #RC_NULL_AREA.
///
/// Only sets the area id's for the un-walkable triangles.  Does not alter the
/// area id's for walkable triangles.
///
/// See the #rcConfig documentation for more information on the configuration parameters.
///
/// @see rcHeightfield, rcClearUnwalkableTriangles, rcRasterizeTriangles
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] walkableSlopeAngle 	The maximum slope that is considered walkable.
/// 									[Limits: 0
///<
///= value
///<
/// 90] [Units: Degrees]
/// @param[in] verts 				The vertices. [(x, y, z) *
///@p
/// @param[in] numVerts 			The number of vertices.
/// @param[in] tris 				The triangle vertex indices. [(vertA, vertB, vertC) *
///@p
/// @param[in] numTris 				The number of triangles.
/// @param[out] triAreaIDs 			The triangle area ids. [Length: >=
///@p
pub const rcClearUnwalkableTriangles = _1_rcClearUnwalkableTriangles_;

extern fn _1_rcAddSpan_(context: [*c]rcContext, heightfield: *rcHeightfield, x: c_int, z: c_int, spanMin: c_ushort, spanMax: c_ushort, areaID: u8, flagMergeThreshold: c_int) bool;
/// Adds a span to the specified heightfield.
///
/// The span addition can be set to favor flags. If the span is merged to
/// another span and the new
///@p
/// is within
///@p
/// units
/// from the existing span, the span flags are merged.
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in,out] heightfield 			An initialized heightfield.
/// @param[in] x 					The column x index where the span is to be added.
/// 									[Limits: 0
///<
///= value
///<
/// rcHeightfield::width]
/// @param[in] z 					The column z index where the span is to be added.
/// 									[Limits: 0
///<
///= value
///<
/// rcHeightfield::height]
/// @param[in] spanMin 				The minimum height of the span. [Limit:
///<
///
///@p
/// [Units: vx]
/// @param[in] spanMax 				The maximum height of the span. [Limit:
///<
///= #RC_SPAN_MAX_HEIGHT] [Units: vx]
/// @param[in] areaID 				The area id of the span. [Limit:
///<
///= #RC_WALKABLE_AREA)
/// @param[in] flagMergeThreshold 	The merge threshold. [Limit: >= 0] [Units: vx]
/// @see True if the operation completed successfully.
pub const rcAddSpan = _1_rcAddSpan_;

extern fn _1_rcRasterizeTriangle_(context: [*c]rcContext, v0: [*c]const f32, v1: [*c]const f32, v2: [*c]const f32, areaID: u8, heightfield: *rcHeightfield, flagMergeThreshold: c_int) bool;
/// Rasterizes a single triangle into the specified heightfield.
///
/// Calling this for each triangle in a mesh is less efficient than calling rcRasterizeTriangles
///
/// No spans will be added if the triangle does not overlap the heightfield grid.
///
/// @see rcHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] v0 					Triangle vertex 0 [(x, y, z)]
/// @param[in] v1 					Triangle vertex 1 [(x, y, z)]
/// @param[in] v2 					Triangle vertex 2 [(x, y, z)]
/// @param[in] areaID 				The area id of the triangle. [Limit:
///<
///= #RC_WALKABLE_AREA]
/// @param[in,out] heightfield 			An initialized heightfield.
/// @param[in] flagMergeThreshold 	The distance where the walkable flag is favored over the non-walkable flag.
/// 									[Limit: >= 0] [Units: vx]
/// @see True if the operation completed successfully.
pub fn rcRasterizeTriangle(
    context: [*c]rcContext,
    v0: [*c]const f32,
    v1: [*c]const f32,
    v2: [*c]const f32,
    areaID: u8,
    heightfield: *rcHeightfield,
    __opt: struct {
        flagMergeThreshold: c_int = 1,
    },
) bool {
    return _1_rcRasterizeTriangle_(context, v0, v1, v2, areaID, heightfield, __opt.flagMergeThreshold);
}

extern fn _1_rcRasterizeTriangles_(context: [*c]rcContext, verts: [*c]const f32, numVerts: c_int, tris: [*c]const c_int, triAreaIDs: [*c]const u8, numTris: c_int, heightfield: *rcHeightfield, flagMergeThreshold: c_int) bool;
/// Rasterizes an indexed triangle mesh into the specified heightfield.
///
/// Spans will only be added for triangles that overlap the heightfield grid.
///
/// @see rcHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] verts 				The vertices. [(x, y, z) *
///@p
/// @param[in] numVerts 			The number of vertices. (unused) TODO (graham): Remove in next major release
/// @param[in] tris 				The triangle indices. [(vertA, vertB, vertC) *
///@p
/// @param[in] triAreaIDs 			The area id's of the triangles. [Limit:
///<
///= #RC_WALKABLE_AREA] [Size:
///@p
/// @param[in] numTris 				The number of triangles.
/// @param[in,out] heightfield 			An initialized heightfield.
/// @param[in] flagMergeThreshold 	The distance where the walkable flag is favored over the non-walkable flag.
///										[Limit: >= 0] [Units: vx]
/// @see True if the operation completed successfully.
pub fn rcRasterizeTriangles(
    context: [*c]rcContext,
    verts: [*c]const f32,
    numVerts: c_int,
    tris: [*c]const c_int,
    triAreaIDs: [*c]const u8,
    numTris: c_int,
    heightfield: *rcHeightfield,
    __opt: struct {
        flagMergeThreshold: c_int = 1,
    },
) bool {
    return _1_rcRasterizeTriangles_(context, verts, numVerts, tris, triAreaIDs, numTris, heightfield, __opt.flagMergeThreshold);
}

extern fn _2_rcRasterizeTriangles_(context: [*c]rcContext, verts: [*c]const f32, numVerts: c_int, tris: [*c]const c_ushort, triAreaIDs: [*c]const u8, numTris: c_int, heightfield: *rcHeightfield, flagMergeThreshold: c_int) bool;
/// Rasterizes an indexed triangle mesh into the specified heightfield.
///
/// Spans will only be added for triangles that overlap the heightfield grid.
///
/// @see rcHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] verts 				The vertices. [(x, y, z) *
///@p
/// @param[in] numVerts 			The number of vertices. (unused) TODO (graham): Remove in next major release
/// @param[in] tris 				The triangle indices. [(vertA, vertB, vertC) *
///@p
/// @param[in] triAreaIDs 			The area id's of the triangles. [Limit:
///<
///= #RC_WALKABLE_AREA] [Size:
///@p
/// @param[in] numTris 				The number of triangles.
/// @param[in,out] heightfield 			An initialized heightfield.
/// @param[in] flagMergeThreshold 	The distance where the walkable flag is favored over the non-walkable flag.
/// 									[Limit: >= 0] [Units: vx]
/// @see True if the operation completed successfully.
pub fn rcRasterizeTriangles__Overload2(
    context: [*c]rcContext,
    verts: [*c]const f32,
    numVerts: c_int,
    tris: [*c]const c_ushort,
    triAreaIDs: [*c]const u8,
    numTris: c_int,
    heightfield: *rcHeightfield,
    __opt: struct {
        flagMergeThreshold: c_int = 1,
    },
) bool {
    return _2_rcRasterizeTriangles_(context, verts, numVerts, tris, triAreaIDs, numTris, heightfield, __opt.flagMergeThreshold);
}

extern fn _3_rcRasterizeTriangles_(context: [*c]rcContext, verts: [*c]const f32, triAreaIDs: [*c]const u8, numTris: c_int, heightfield: *rcHeightfield, flagMergeThreshold: c_int) bool;
/// Rasterizes a triangle list into the specified heightfield.
///
/// Expects each triangle to be specified as three sequential vertices of 3 floats.
///
/// Spans will only be added for triangles that overlap the heightfield grid.
///
/// @see rcHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] verts 				The triangle vertices. [(ax, ay, az, bx, by, bz, cx, by, cx) *
///@p
/// @param[in] triAreaIDs 			The area id's of the triangles. [Limit:
///<
///= #RC_WALKABLE_AREA] [Size:
///@p
/// @param[in] numTris 				The number of triangles.
/// @param[in,out] heightfield 			An initialized heightfield.
/// @param[in] flagMergeThreshold 	The distance where the walkable flag is favored over the non-walkable flag.
/// 									[Limit: >= 0] [Units: vx]
/// @see True if the operation completed successfully.
pub fn rcRasterizeTriangles__Overload3(
    context: [*c]rcContext,
    verts: [*c]const f32,
    triAreaIDs: [*c]const u8,
    numTris: c_int,
    heightfield: *rcHeightfield,
    __opt: struct {
        flagMergeThreshold: c_int = 1,
    },
) bool {
    return _3_rcRasterizeTriangles_(context, verts, triAreaIDs, numTris, heightfield, __opt.flagMergeThreshold);
}

extern fn _1_rcFilterLowHangingWalkableObstacles_(context: [*c]rcContext, walkableClimb: c_int, heightfield: *rcHeightfield) void;
/// Marks non-walkable spans as walkable if their maximum is within
///@p
/// of the span below them.
///
/// This removes small obstacles and rasterization artifacts that the agent would be able to walk over
/// such as curbs.  It also allows agents to move up terraced structures like stairs.
///
/// Obstacle spans are marked walkable if:
///
///obstacleSpan.smax - walkableSpan.smax
///<
/// walkableClimb
///
///
/// @see Will override the effect of #rcFilterLedgeSpans.  If both filters are used, call #rcFilterLedgeSpans only after applying this filter.
///
/// @see rcHeightfield, rcConfig
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 			The build context to use during the operation.
/// @param[in] walkableClimb 	Maximum ledge height that is considered to still be traversable.
/// 								[Limit: >=0] [Units: vx]
/// @param[in,out] heightfield 		A fully built heightfield.  (All spans have been added.)
pub const rcFilterLowHangingWalkableObstacles = _1_rcFilterLowHangingWalkableObstacles_;

extern fn _1_rcFilterLedgeSpans_(context: [*c]rcContext, walkableHeight: c_int, walkableClimb: c_int, heightfield: *rcHeightfield) void;
/// Marks spans that are ledges as not-walkable.
///
/// A ledge is a span with one or more neighbors whose maximum is further away than
///@p
/// from the current span's maximum.
/// This method removes the impact of the overestimation of conservative voxelization
/// so the resulting mesh will not have regions hanging in the air over ledges.
///
/// A span is a ledge if:
///
///rcAbs(currentSpan.smax - neighborSpan.smax) > walkableClimb
///
///
/// @see rcHeightfield, rcConfig
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] walkableHeight 	Minimum floor to 'ceiling' height that will still allow the floor area to
/// 								be considered walkable. [Limit: >= 3] [Units: vx]
/// @param[in] walkableClimb 	Maximum ledge height that is considered to still be traversable.
/// 								[Limit: >=0] [Units: vx]
/// @param[in,out] heightfield 			A fully built heightfield.  (All spans have been added.)
pub const rcFilterLedgeSpans = _1_rcFilterLedgeSpans_;

extern fn _1_rcFilterWalkableLowHeightSpans_(context: [*c]rcContext, walkableHeight: c_int, heightfield: *rcHeightfield) void;
/// Marks walkable spans as not walkable if the clearance above the span is less than the specified walkableHeight.
///
/// For this filter, the clearance above the span is the distance from the span's
/// maximum to the minimum of the next higher span in the same column.
/// If there is no higher span in the column, the clearance is computed as the
/// distance from the top of the span to the maximum heightfield height.
///
/// @see rcHeightfield, rcConfig
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 			The build context to use during the operation.
/// @param[in] walkableHeight 	Minimum floor to 'ceiling' height that will still allow the floor area to
/// 								be considered walkable. [Limit: >= 3] [Units: vx]
/// @param[in,out] heightfield 		A fully built heightfield.  (All spans have been added.)
pub const rcFilterWalkableLowHeightSpans = _1_rcFilterWalkableLowHeightSpans_;

extern fn _1_rcGetHeightFieldSpanCount_(context: [*c]rcContext, heightfield: *const rcHeightfield) c_int;
/// Returns the number of spans contained in the specified heightfield.
///  @UntranspiledVerbatimLineCommentCommand recast
///
///  @param[in,out] context 		The build context to use during the operation.
///  @param[in] heightfield 	An initialized heightfield.
///  @see The number of spans in the heightfield.
pub const rcGetHeightFieldSpanCount = _1_rcGetHeightFieldSpanCount_;

extern fn _1_rcBuildCompactHeightfield_(context: [*c]rcContext, walkableHeight: c_int, walkableClimb: c_int, heightfield: *const rcHeightfield, compactHeightfield: *rcCompactHeightfield) bool;
/// Builds a compact heightfield representing open space, from a heightfield representing solid space.
///
/// This is just the beginning of the process of fully building a compact heightfield.
/// Various filters may be applied, then the distance field and regions built.
/// E.g: #rcBuildDistanceField and #rcBuildRegions
///
/// See the #rcConfig documentation for more information on the configuration parameters.
///
/// @see rcAllocCompactHeightfield, rcHeightfield, rcCompactHeightfield, rcConfig
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] walkableHeight 		Minimum floor to 'ceiling' height that will still allow the floor area
/// 									to be considered walkable. [Limit: >= 3] [Units: vx]
/// @param[in] walkableClimb 		Maximum ledge height that is considered to still be traversable.
/// 									[Limit: >=0] [Units: vx]
/// @param[in] heightfield 			The heightfield to be compacted.
/// @param[out] compactHeightfield 	The resulting compact heightfield. (Must be pre-allocated.)
/// @see True if the operation completed successfully.
pub const rcBuildCompactHeightfield = _1_rcBuildCompactHeightfield_;

extern fn _1_rcErodeWalkableArea_(context: [*c]rcContext, erosionRadius: c_int, compactHeightfield: *rcCompactHeightfield) bool;
/// Erodes the walkable area within the heightfield by the specified radius.
///
/// Basically, any spans that are closer to a boundary or obstruction than the specified radius
/// are marked as un-walkable.
///
/// This method is usually called immediately after the heightfield has been built.
///
/// @see rcCompactHeightfield, rcBuildCompactHeightfield, rcConfig::walkableRadius
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] erosionRadius 		The radius of erosion. [Limits: 0
///<
/// value
///<
/// 255] [Units: vx]
/// @param[in,out] compactHeightfield 	The populated compact heightfield to erode.
/// @see True if the operation completed successfully.
pub const rcErodeWalkableArea = _1_rcErodeWalkableArea_;

extern fn _1_rcMedianFilterWalkableArea_(context: [*c]rcContext, compactHeightfield: *rcCompactHeightfield) bool;
/// Applies a median filter to walkable area types (based on area id), removing noise.
///
/// This filter is usually applied after applying area id's using functions
/// such as #rcMarkBoxArea, #rcMarkConvexPolyArea, and #rcMarkCylinderArea.
///
/// @see rcCompactHeightfield
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 		The build context to use during the operation.
/// @param[in,out] compactHeightfield 		A populated compact heightfield.
/// @see True if the operation completed successfully.
pub const rcMedianFilterWalkableArea = _1_rcMedianFilterWalkableArea_;

extern fn _1_rcMarkBoxArea_(context: [*c]rcContext, boxMinBounds: [*c]const f32, boxMaxBounds: [*c]const f32, areaId: u8, compactHeightfield: *rcCompactHeightfield) void;
/// Applies an area id to all spans within the specified bounding box. (AABB)
///
/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] boxMinBounds 		The minimum extents of the bounding box. [(x, y, z)] [Units: wu]
/// @param[in] boxMaxBounds 		The maximum extents of the bounding box. [(x, y, z)] [Units: wu]
/// @param[in] areaId 				The area id to apply. [Limit:
///<
///= #RC_WALKABLE_AREA]
/// @param[in,out] compactHeightfield 	A populated compact heightfield.
pub const rcMarkBoxArea = _1_rcMarkBoxArea_;

extern fn _1_rcMarkConvexPolyArea_(context: [*c]rcContext, verts: [*c]const f32, numVerts: c_int, minY: f32, maxY: f32, areaId: u8, compactHeightfield: *rcCompactHeightfield) void;
/// Applies the area id to the all spans within the specified convex polygon.
///
/// The value of spacial parameters are in world units.
///
/// The y-values of the polygon vertices are ignored. So the polygon is effectively
/// projected onto the xz-plane, translated to
///@p
/// and extruded to
///@p
///
/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] verts 				The vertices of the polygon [For: (x, y, z) *
///@p
/// @param[in] numVerts 			The number of vertices in the polygon.
/// @param[in] minY 				The height of the base of the polygon. [Units: wu]
/// @param[in] maxY 				The height of the top of the polygon. [Units: wu]
/// @param[in] areaId 				The area id to apply. [Limit:
///<
///= #RC_WALKABLE_AREA]
/// @param[in,out] compactHeightfield 	A populated compact heightfield.
pub const rcMarkConvexPolyArea = _1_rcMarkConvexPolyArea_;

extern fn _1_rcOffsetPoly_(verts: [*c]const f32, numVerts: c_int, offset: f32, outVerts: [*c]f32, maxOutVerts: c_int) c_int;
/// Expands a convex polygon along its vertex normals by the given offset amount.
/// Inserts extra vertices to bevel sharp corners.
///
/// Helper function to offset convex polygons for rcMarkConvexPolyArea.
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in] verts 		The vertices of the polygon [Form: (x, y, z) *
///@p
/// @param[in] numVerts 	The number of vertices in the polygon.
/// @param[in] offset 		How much to offset the polygon by. [Units: wu]
/// @param[out] outVerts 	The offset vertices (should hold up to 2 *
///@p
/// [Form: (x, y, z) * return value]
/// @param[in] maxOutVerts 	The max number of vertices that can be stored to
///@p
/// @see Number of vertices in the offset polygon or 0 if too few vertices in
///@p
pub const rcOffsetPoly = _1_rcOffsetPoly_;

extern fn _1_rcMarkCylinderArea_(context: [*c]rcContext, position: [*c]const f32, radius: f32, height: f32, areaId: u8, compactHeightfield: *rcCompactHeightfield) void;
/// Applies the area id to all spans within the specified y-axis-aligned cylinder.
///
/// @see rcCompactHeightfield, rcMedianFilterWalkableArea
///
/// @UntranspiledVerbatimLineCommentCommand recast
///
///
/// @param[in,out] context 				The build context to use during the operation.
/// @param[in] position 			The center of the base of the cylinder. [Form: (x, y, z)] [Units: wu]
/// @param[in] radius 				The radius of the cylinder. [Units: wu] [Limit: > 0]
/// @param[in] height 				The height of the cylinder. [Units: wu] [Limit: > 0]
/// @param[in] areaId 				The area id to apply. [Limit:
///<
///= #RC_WALKABLE_AREA]
/// @param[in,out] compactHeightfield 	A populated compact heightfield.
pub const rcMarkCylinderArea = _1_rcMarkCylinderArea_;

extern fn _1_rcBuildDistanceField_(ctx: [*c]rcContext, chf: *rcCompactHeightfield) bool;
/// Builds the distance field for the specified compact heightfield.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 		The build context to use during the operation.
/// @param[in,out] chf 		A populated compact heightfield.
/// @see True if the operation completed successfully.
pub const rcBuildDistanceField = _1_rcBuildDistanceField_;

extern fn _1_rcBuildRegions_(ctx: [*c]rcContext, chf: *rcCompactHeightfield, borderSize: c_int, minRegionArea: c_int, mergeRegionArea: c_int) bool;
/// Builds region data for the heightfield using watershed partitioning.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 				The build context to use during the operation.
/// @param[in,out] chf 				A populated compact heightfield.
/// @param[in] borderSize 		The size of the non-navigable border around the heightfield.
/// 								[Limit: >=0] [Units: vx]
/// @param[in] minRegionArea 	The minimum number of cells allowed to form isolated island areas.
/// 								[Limit: >=0] [Units: vx].
/// @param[in] mergeRegionArea 	Any regions with a span count smaller than this value will, if possible,
/// 								be merged with larger regions. [Limit: >=0] [Units: vx]
/// @see True if the operation completed successfully.
pub const rcBuildRegions = _1_rcBuildRegions_;

extern fn _1_rcBuildLayerRegions_(ctx: [*c]rcContext, chf: *rcCompactHeightfield, borderSize: c_int, minRegionArea: c_int) bool;
/// Builds region data for the heightfield by partitioning the heightfield in non-overlapping layers.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 				The build context to use during the operation.
/// @param[in,out] chf 				A populated compact heightfield.
/// @param[in] borderSize 		The size of the non-navigable border around the heightfield.
///  								[Limit: >=0] [Units: vx]
/// @param[in] minRegionArea 	The minimum number of cells allowed to form isolated island areas.
///  								[Limit: >=0] [Units: vx].
/// @see True if the operation completed successfully.
pub const rcBuildLayerRegions = _1_rcBuildLayerRegions_;

extern fn _1_rcBuildRegionsMonotone_(ctx: [*c]rcContext, chf: *rcCompactHeightfield, borderSize: c_int, minRegionArea: c_int, mergeRegionArea: c_int) bool;
/// Builds region data for the heightfield using simple monotone partitioning.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 				The build context to use during the operation.
/// @param[in,out] chf 				A populated compact heightfield.
/// @param[in] borderSize 		The size of the non-navigable border around the heightfield.
///  								[Limit: >=0] [Units: vx]
/// @param[in] minRegionArea 	The minimum number of cells allowed to form isolated island areas.
///  								[Limit: >=0] [Units: vx].
/// @param[in] mergeRegionArea 	Any regions with a span count smaller than this value will, if possible,
///  								be merged with larger regions. [Limit: >=0] [Units: vx]
/// @see True if the operation completed successfully.
pub const rcBuildRegionsMonotone = _1_rcBuildRegionsMonotone_;

extern fn _1_rcSetCon_(span: *rcCompactSpan, direction: c_int, neighborIndex: c_int) void;
/// Sets the neighbor connection data for the specified direction.
/// @param[in] span 			The span to update.
/// @param[in] direction 		The direction to set. [Limits: 0
///<
///= value
///<
/// 4]
/// @param[in] neighborIndex 	The index of the neighbor span.
pub const rcSetCon = _1_rcSetCon_;

extern fn _1_rcGetCon_(span: *const rcCompactSpan, direction: c_int) c_int;
/// Gets neighbor connection data for the specified direction.
/// @param[in] span 		The span to check.
/// @param[in] direction 	The direction to check. [Limits: 0
///<
///= value
///<
/// 4]
/// @see The neighbor connection data for the specified direction, or #RC_NOT_CONNECTED if there is no connection.
pub const rcGetCon = _1_rcGetCon_;

extern fn _1_rcGetDirOffsetX_(direction: c_int) c_int;
/// Gets the standard width (x-axis) offset for the specified direction.
/// @param[in] direction 		The direction. [Limits: 0
///<
///= value
///<
/// 4]
/// @see The width offset to apply to the current cell position to move in the direction.
pub const rcGetDirOffsetX = _1_rcGetDirOffsetX_;

extern fn _1_rcGetDirOffsetY_(direction: c_int) c_int;
/// TODO (graham): Rename this to rcGetDirOffsetZ
/// Gets the standard height (z-axis) offset for the specified direction.
/// @param[in] direction 		The direction. [Limits: 0
///<
///= value
///<
/// 4]
/// @see The height offset to apply to the current cell position to move in the direction.
pub const rcGetDirOffsetY = _1_rcGetDirOffsetY_;

extern fn _1_rcGetDirForOffset_(offsetX: c_int, offsetZ: c_int) c_int;
/// Gets the direction for the specified offset. One of x and y should be 0.
/// @param[in] offsetX 		The x offset. [Limits: -1
///<
///= value
///<
///= 1]
/// @param[in] offsetZ 		The z offset. [Limits: -1
///<
///= value
///<
///= 1]
/// @see The direction that represents the offset.
pub const rcGetDirForOffset = _1_rcGetDirForOffset_;

extern fn _1_rcBuildHeightfieldLayers_(ctx: [*c]rcContext, chf: *const rcCompactHeightfield, borderSize: c_int, walkableHeight: c_int, lset: *rcHeightfieldLayerSet) bool;
/// Builds a layer set from the specified compact heightfield.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 				The build context to use during the operation.
/// @param[in] chf 				A fully built compact heightfield.
/// @param[in] borderSize 		The size of the non-navigable border around the heightfield. [Limit: >=0]
///  								[Units: vx]
/// @param[in] walkableHeight 	Minimum floor to 'ceiling' height that will still allow the floor area
///  								to be considered walkable. [Limit: >= 3] [Units: vx]
/// @param[out] lset 			The resulting layer set. (Must be pre-allocated.)
/// @see True if the operation completed successfully.
pub const rcBuildHeightfieldLayers = _1_rcBuildHeightfieldLayers_;

extern fn _1_rcBuildContours_(ctx: [*c]rcContext, chf: *const rcCompactHeightfield, maxError: f32, maxEdgeLen: c_int, cset: *rcContourSet, buildFlags: c_int) bool;
/// Builds a contour set from the region outlines in the provided compact heightfield.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 			The build context to use during the operation.
/// @param[in] chf 			A fully built compact heightfield.
/// @param[in] maxError 	The maximum distance a simplified contour's border edges should deviate
/// 							the original raw contour. [Limit: >=0] [Units: wu]
/// @param[in] maxEdgeLen 	The maximum allowed length for contour edges along the border of the mesh.
/// 							[Limit: >=0] [Units: vx]
/// @param[out] cset 		The resulting contour set. (Must be pre-allocated.)
/// @param[in] buildFlags 	The build flags. (See: #rcBuildContoursFlags)
/// @see True if the operation completed successfully.
pub fn rcBuildContours(
    ctx: [*c]rcContext,
    chf: *const rcCompactHeightfield,
    maxError: f32,
    maxEdgeLen: c_int,
    cset: *rcContourSet,
    __opt: struct {
        buildFlags: c_int = @as(c_int, @intCast(rcBuildContoursFlags.RC_CONTOUR_TESS_WALL_EDGES.bits)),
    },
) bool {
    return _1_rcBuildContours_(ctx, chf, maxError, maxEdgeLen, cset, __opt.buildFlags);
}

extern fn _1_rcBuildPolyMesh_(ctx: [*c]rcContext, cset: *const rcContourSet, nvp: c_int, mesh: *rcPolyMesh) bool;
/// Builds a polygon mesh from the provided contours.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 		The build context to use during the operation.
/// @param[in] cset 	A fully built contour set.
/// @param[in] nvp 		The maximum number of vertices allowed for polygons generated during the
/// 						contour to polygon conversion process. [Limit: >= 3]
/// @param[out] mesh 	The resulting polygon mesh. (Must be re-allocated.)
/// @see True if the operation completed successfully.
pub const rcBuildPolyMesh = _1_rcBuildPolyMesh_;

extern fn _1_rcMergePolyMeshes_(ctx: [*c]rcContext, meshes: [*c][*c]rcPolyMesh, nmeshes: c_int, mesh: *rcPolyMesh) bool;
/// Merges multiple polygon meshes into a single mesh.
///  @UntranspiledVerbatimLineCommentCommand recast
///
///  @param[in,out] ctx 		The build context to use during the operation.
///  @param[in] meshes 	An array of polygon meshes to merge. [Size:
///@p
///  @param[in] nmeshes 	The number of polygon meshes in the meshes array.
///  @param[in] mesh 	The resulting polygon mesh. (Must be pre-allocated.)
///  @see True if the operation completed successfully.
pub const rcMergePolyMeshes = _1_rcMergePolyMeshes_;

extern fn _1_rcBuildPolyMeshDetail_(ctx: [*c]rcContext, mesh: *const rcPolyMesh, chf: *const rcCompactHeightfield, sampleDist: f32, sampleMaxError: f32, dmesh: *rcPolyMeshDetail) bool;
/// Builds a detail mesh from the provided polygon mesh.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 				The build context to use during the operation.
/// @param[in] mesh 			A fully built polygon mesh.
/// @param[in] chf 				The compact heightfield used to build the polygon mesh.
/// @param[in] sampleDist 		Sets the distance to use when sampling the heightfield. [Limit: >=0] [Units: wu]
/// @param[in] sampleMaxError 	The maximum distance the detail mesh surface should deviate from
/// 								heightfield data. [Limit: >=0] [Units: wu]
/// @param[out] dmesh 			The resulting detail mesh.  (Must be pre-allocated.)
/// @see True if the operation completed successfully.
pub const rcBuildPolyMeshDetail = _1_rcBuildPolyMeshDetail_;

extern fn _1_rcCopyPolyMesh_(ctx: [*c]rcContext, src: *const rcPolyMesh, dst: *rcPolyMesh) bool;
/// Copies the poly mesh data from src to dst.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 		The build context to use during the operation.
/// @param[in] src 		The source mesh to copy from.
/// @param[out] dst 		The resulting detail mesh. (Must be pre-allocated, must be empty mesh.)
/// @see True if the operation completed successfully.
pub const rcCopyPolyMesh = _1_rcCopyPolyMesh_;

extern fn _1_rcMergePolyMeshDetails_(ctx: [*c]rcContext, meshes: [*c][*c]rcPolyMeshDetail, nmeshes: c_int, mesh: *rcPolyMeshDetail) bool;
/// Merges multiple detail meshes into a single detail mesh.
/// @UntranspiledVerbatimLineCommentCommand recast
///
/// @param[in,out] ctx 		The build context to use during the operation.
/// @param[in] meshes 	An array of detail meshes to merge. [Size:
///@p
/// @param[in] nmeshes 	The number of detail meshes in the meshes array.
/// @param[out] mesh 	The resulting detail mesh. (Must be pre-allocated.)
/// @see True if the operation completed successfully.
pub const rcMergePolyMeshDetails = _1_rcMergePolyMeshDetails_;
